<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jumpasaurus - Dinosaur Food Collector</title>
    <style>
      body {
        margin: 0;
        padding: 10px;
        background: #000000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: 'Courier New', monospace;
        overflow: hidden;
        box-sizing: border-box;
        color: white;
        position: relative;
      }

      body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(255, 255, 255, 0.03) 2px,
          rgba(255, 255, 255, 0.03) 4px
        );
        pointer-events: none;
        z-index: 100;
      }

      #gameCanvas {
        border: 2px solid white;
        background: #87ceeb;
        max-width: 95vw;
        max-height: 90vh;
        position: relative;
        z-index: 1;
      }
      .back-button {
        position: absolute;
        top: 20px;
        left: 20px;
        background: black;
        color: white;
        border: 2px solid white;
        padding: 8px 16px;
        border-radius: 0;
        font-size: 12px;
        font-weight: 900;
        cursor: pointer;
        transition: all 0.3s ease;
        text-decoration: none;
        display: inline-block;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-family: 'Courier New', monospace;
        z-index: 1000;
      }
      .back-button:hover {
        background: white;
        color: black;
        border: 2px solid black;
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="back-button">Back</a>
    <canvas id="gameCanvas" width="1200" height="600"></canvas>
    <script>
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      let audioContext;
      let masterGain;
      let musicGain;
      let gameRunning = true;

      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          masterGain = audioContext.createGain();
          masterGain.gain.value = 0.4;
          masterGain.connect(audioContext.destination);
          musicGain = audioContext.createGain();
          musicGain.gain.value = 0.2;
          musicGain.connect(masterGain);
        } catch (e) {
          console.log('Web Audio API not supported');
        }
      }

      function playBackgroundMusic() {
        if (!audioContext || !gameRunning) return;

        const melody1 = audioContext.createOscillator();
        const melody2 = audioContext.createOscillator();
        const bass = audioContext.createOscillator();
        const filter1 = audioContext.createBiquadFilter();
        const filter2 = audioContext.createBiquadFilter();
        const filterBass = audioContext.createBiquadFilter();
        const gain1 = audioContext.createGain();
        const gain2 = audioContext.createGain();
        const gainBass = audioContext.createGain();

        melody1.type = 'sine';
        melody2.type = 'triangle';
        bass.type = 'sawtooth';

        const notes1 = [523.25, 587.33, 659.25, 698.46];
        const notes2 = [392.0, 440.0, 493.88, 523.25];
        const bassNotes = [130.81, 146.83, 164.81, 174.61];

        let noteIndex = 0;
        const startTime = audioContext.currentTime;

        function playNote(osc, notes, delay, duration) {
          const note = notes[noteIndex % notes.length];
          osc.frequency.setValueAtTime(note, startTime + delay);
          osc.frequency.setValueAtTime(
            note * 1.05,
            startTime + delay + duration * 0.1
          );
          osc.frequency.setValueAtTime(
            note,
            startTime + delay + duration * 0.2
          );
        }

        playNote(melody1, notes1, 0, 0.5);
        playNote(melody2, notes2, 0.25, 0.5);
        playNote(bass, bassNotes, 0, 1);

        filter1.type = 'lowpass';
        filter1.frequency.setValueAtTime(2000, audioContext.currentTime);
        filter2.type = 'lowpass';
        filter2.frequency.setValueAtTime(1500, audioContext.currentTime);
        filterBass.type = 'lowpass';
        filterBass.frequency.setValueAtTime(800, audioContext.currentTime);

        gain1.gain.setValueAtTime(0.15, audioContext.currentTime);
        gain2.gain.setValueAtTime(0.12, audioContext.currentTime);
        gainBass.gain.setValueAtTime(0.08, audioContext.currentTime);

        melody1.connect(filter1);
        filter1.connect(gain1);
        gain1.connect(musicGain);

        melody2.connect(filter2);
        filter2.connect(gain2);
        gain2.connect(musicGain);

        bass.connect(filterBass);
        filterBass.connect(gainBass);
        gainBass.connect(musicGain);

        const now = audioContext.currentTime;
        melody1.start(now);
        melody2.start(now);
        bass.start(now);

        melody1.stop(now + 4);
        melody2.stop(now + 4);
        bass.stop(now + 4);

        setTimeout(() => {
          if (gameRunning && audioContext) {
            playBackgroundMusic();
          }
        }, 4000);
      }

      function playJumpSound() {
        if (!audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();

        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(masterGain);

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
        oscillator.frequency.linearRampToValueAtTime(
          450,
          audioContext.currentTime + 0.08
        );
        oscillator.frequency.linearRampToValueAtTime(
          200,
          audioContext.currentTime + 0.15
        );

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1200, audioContext.currentTime);

        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(
          0.12,
          audioContext.currentTime + 0.05
        );
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.15
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.15);
      }

      function playFoodSound() {
        if (!audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(masterGain);

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(
          1000,
          audioContext.currentTime + 0.05
        );
        oscillator.frequency.setValueAtTime(
          1200,
          audioContext.currentTime + 0.1
        );

        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + 0.1);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.15
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.15);
      }

      function playGameOverSound() {
        if (!audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();

        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(masterGain);

        oscillator.type = 'sawtooth';
        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          150,
          audioContext.currentTime + 0.8
        );

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1000, audioContext.currentTime);
        filter.frequency.exponentialRampToValueAtTime(
          200,
          audioContext.currentTime + 0.8
        );

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.8
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.8);
      }

      function playThemeToggleSound() {
        if (!audioContext) return;

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(masterGain);

        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(
          800,
          audioContext.currentTime + 0.05
        );

        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.1
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
      }

      let audioInitialized = false;
      document.addEventListener('click', () => {
        if (!audioInitialized) {
          initAudio();
          audioInitialized = true;
        }
      });

      document.addEventListener('keydown', () => {
        if (!audioInitialized) {
          initAudio();
          audioInitialized = true;
        }
      });

      let score = 0;
      let gameTime = 0;
      const dino = {
        x: 50,
        y: 300,
        width: 50,
        height: 50,
        velocityY: 0,
        gravity: 0.8,
        jumpPower: -15,
        onGround: false,
        jumpsRemaining: 5,
        maxJumps: 5,
      };

      const foods = [];
      let foodSpawnTimer = 0;
      let groundPattern = [];
      const obstacles = [];
      let obstacleSpawnTimer = 0;
      let gameOver = false;
      let darkMode = true;

      const themes = {
        dark: {
          sky: '#1a1a2e',
          ground: '#2d2d44',
          groundBlocks: ['#4a4a5e', '#3a3a4a'],
          grass: ['#3d5a3d', '#4a6b4a'],
          dino: {
            main: '#4a6741',
            legs: '#3a5038',
            feet: '#2a3a28',
            spots: '#3a5038',
            spikes: '#5a7c57',
          },
          cactus: {
            main: '#4a5c4a',
            spikes: '#2a3a2a',
            highlight: '#6a7c6a',
          },
          text: '#FFF',
          subText: '#CCC',
          food: ['#ff8a8a', '#8ac4ff', '#85c1ff', '#b6d4b6', '#ffdf8a'],
        },
        light: {
          sky: '#87CEEB',
          ground: '#8B4513',
          groundBlocks: ['#A0522D', '#654321'],
          grass: ['#228B22', '#32CD32'],
          dino: {
            main: '#228B22',
            legs: '#1F5F1F',
            feet: '#0F3F0F',
            spots: '#1F5F1F',
            spikes: '#32CD32',
          },
          cactus: {
            main: '#2F4F2F',
            spikes: '#1C3A1C',
            highlight: '#4F6F4F',
          },
          text: '#000',
          subText: '#FFF',
          food: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'],
        },
      };

      function getCurrentTheme() {
        return darkMode ? themes.dark : themes.light;
      }

      const foodTypes = [
        { color: getCurrentTheme().food[0], points: 50 },
        { color: getCurrentTheme().food[1], points: 75 },
        { color: getCurrentTheme().food[2], points: 100 },
        { color: getCurrentTheme().food[3], points: 125 },
        { color: getCurrentTheme().food[4], points: 150 },
      ];

      function generateGroundPattern() {
        groundPattern = [];
        for (let x = 0; x < canvas.width; x += 20) {
          for (let y = canvas.height - 100; y < canvas.height; y += 20) {
            if (Math.random() > 0.6) {
              groundPattern.push({ x: x, y: y, size: 20, color: '#A0522D' });
            }
          }
        }

        for (let x = 0; x < canvas.width; x += 15) {
          for (let y = canvas.height - 80; y < canvas.height; y += 15) {
            if (Math.random() > 0.7) {
              groundPattern.push({ x: x, y: y, size: 15, color: '#654321' });
            }
          }
        }

        for (let x = 0; x < canvas.width; x += 10) {
          let grassColors = getCurrentTheme().grass;
          let grassColor =
            Math.random() > 0.5 ? grassColors[0] : grassColors[1];
          let grassHeight = Math.floor(Math.random() * 8) + 12;
          groundPattern.push({
            x: x,
            y: canvas.height - 100,
            width: 10,
            height: grassHeight,
            color: grassColor,
            isGrass: true,
          });
        }
      }

      function init() {
        dino.y = canvas.height - 100 - dino.height;
        generateGroundPattern();
        gameLoop();
      }
      function spawnFood() {
        const foodColors = getCurrentTheme().food;
        const foodTypes = [
          { color: foodColors[0], points: 50 },
          { color: foodColors[1], points: 75 },
          { color: foodColors[2], points: 100 },
          { color: foodColors[3], points: 125 },
          { color: foodColors[4], points: 150 },
        ];
        const foodType =
          foodTypes[Math.floor(Math.random() * foodTypes.length)];
        foods.push({
          x: canvas.width,
          y: Math.random() * (canvas.height - 300) + 100,
          width: 30,
          height: 30,
          color: foodType.color,
          points: foodType.points,
          speed: 3 + Math.random() * 2,
        });
      }

      function spawnObstacle() {
        let baseSpeed = 3;
        let speedMultiplier = 1;

        if (score >= 5000) {
          speedMultiplier = 2.5;
        } else if (score >= 3000) {
          speedMultiplier = 2;
        } else if (score >= 1000) {
          speedMultiplier = 1.5;
        }

        obstacles.push({
          x: canvas.width,
          y: canvas.height - 100 - 40,
          width: 20,
          height: 40,
          speed: (baseSpeed + Math.random() * 1.5) * speedMultiplier,
        });
      }

      function update() {
        if (gameOver) return;

        gameTime++;

        dino.velocityY += dino.gravity;
        dino.y += dino.velocityY;
        const groundY = canvas.height - 100;
        if (dino.y + dino.height >= groundY) {
          dino.y = groundY - dino.height;
          dino.velocityY = 0;
          dino.onGround = true;
          dino.jumpsRemaining = dino.maxJumps;
        } else {
          dino.onGround = false;
        }

        if (dino.y < 0) {
          dino.y = 0;
          dino.velocityY = 0;
        }

        foodSpawnTimer++;
        if (foodSpawnTimer >= 60) {
          spawnFood();
          foodSpawnTimer = 0;
        }

        obstacleSpawnTimer++;

        let obstacleSpawnRate = 180;
        if (score >= 5000) {
          obstacleSpawnRate = 90;
        } else if (score >= 3000) {
          obstacleSpawnRate = 120;
        } else if (score >= 1500) {
          obstacleSpawnRate = 150;
        }

        if (obstacleSpawnTimer >= obstacleSpawnRate) {
          spawnObstacle();
          obstacleSpawnTimer = 0;
        }

        for (let i = foods.length - 1; i >= 0; i--) {
          const food = foods[i];
          food.x -= food.speed;

          if (
            dino.x < food.x + food.width &&
            dino.x + dino.width > food.x &&
            dino.y < food.y + food.height &&
            dino.y + dino.height > food.y
          ) {
            score += food.points;
            playFoodSound();
            foods.splice(i, 1);
            continue;
          }

          if (food.x + food.width < 0) {
            foods.splice(i, 1);
          }
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obstacle = obstacles[i];
          obstacle.x -= obstacle.speed;

          if (
            dino.x < obstacle.x + obstacle.width &&
            dino.x + dino.width > obstacle.x &&
            dino.y < obstacle.y + obstacle.height &&
            dino.y + dino.height > obstacle.y
          ) {
            gameOver = true;
            gameRunning = false;
            playGameOverSound();
            break;
          }

          if (obstacle.x + obstacle.width < 0) {
            obstacles.splice(i, 1);
          }
        }
      }

      function draw() {
        const theme = getCurrentTheme();

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = theme.sky;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = theme.ground;
        ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

        groundPattern.forEach(block => {
          if (block.isGrass) {
            ctx.fillStyle = block.color;
            ctx.fillRect(block.x, block.y, block.width, block.height);
          } else {
            let darkColor =
              block.color === '#A0522D'
                ? theme.groundBlocks[0]
                : theme.groundBlocks[1];
            ctx.fillStyle = darkColor;
            ctx.fillRect(block.x, block.y, block.size, block.size);
          }
        });

        const dinoX = dino.x;
        const dinoY = dino.y;
        const dinoW = dino.width;
        const dinoH = dino.height;

        ctx.fillStyle = theme.dino.main;
        ctx.fillRect(
          dinoX + dinoW * 0.3,
          dinoY + dinoH * 0.5,
          dinoW * 0.4,
          dinoH * 0.3
        );

        ctx.fillStyle = theme.dino.main;
        ctx.fillRect(
          dinoX + dinoW * 0.65,
          dinoY + dinoH * 0.35,
          dinoW * 0.1,
          dinoH * 0.2
        );
        ctx.fillRect(
          dinoX + dinoW * 0.7,
          dinoY + dinoH * 0.25,
          dinoW * 0.08,
          dinoH * 0.15
        );

        ctx.fillStyle = theme.dino.main;
        ctx.fillRect(
          dinoX + dinoW * 0.75,
          dinoY + dinoH * 0.15,
          dinoW * 0.15,
          dinoH * 0.12
        );

        ctx.fillStyle = theme.dino.main;
        ctx.fillRect(
          dinoX + dinoW * 0.88,
          dinoY + dinoH * 0.2,
          dinoW * 0.08,
          dinoH * 0.06
        );

        ctx.fillStyle = theme.dino.main;
        ctx.fillRect(
          dinoX + dinoW * 0.1,
          dinoY + dinoH * 0.65,
          dinoW * 0.25,
          dinoH * 0.1
        );
        ctx.fillRect(
          dinoX - dinoW * 0.05,
          dinoY + dinoH * 0.68,
          dinoW * 0.18,
          dinoH * 0.08
        );
        ctx.fillRect(
          dinoX - dinoW * 0.15,
          dinoY + dinoH * 0.7,
          dinoW * 0.12,
          dinoH * 0.06
        );

        ctx.fillStyle = theme.dino.legs;
        ctx.fillRect(
          dinoX + dinoW * 0.35,
          dinoY + dinoH * 0.8,
          dinoW * 0.08,
          dinoH * 0.25
        );
        ctx.fillRect(
          dinoX + dinoW * 0.5,
          dinoY + dinoH * 0.8,
          dinoW * 0.08,
          dinoH * 0.25
        );

        ctx.fillStyle = theme.dino.feet;
        ctx.fillRect(
          dinoX + dinoW * 0.32,
          dinoY + dinoH * 1.0,
          dinoW * 0.14,
          dinoH * 0.08
        );
        ctx.fillRect(
          dinoX + dinoW * 0.47,
          dinoY + dinoH * 1.0,
          dinoW * 0.14,
          dinoH * 0.08
        );

        ctx.fillStyle = theme.dino.legs;
        ctx.fillRect(
          dinoX + dinoW * 0.65,
          dinoY + dinoH * 0.55,
          dinoW * 0.04,
          dinoH * 0.1
        );

        ctx.fillStyle = '#000';
        ctx.fillRect(
          dinoX + dinoW * 0.8,
          dinoY + dinoH * 0.18,
          dinoW * 0.04,
          dinoH * 0.03
        );

        ctx.fillStyle = '#FFF';
        ctx.fillRect(
          dinoX + dinoW * 0.82,
          dinoY + dinoH * 0.185,
          dinoW * 0.015,
          dinoH * 0.015
        );

        ctx.fillStyle = '#000';
        ctx.fillRect(
          dinoX + dinoW * 0.9,
          dinoY + dinoH * 0.22,
          dinoW * 0.02,
          dinoH * 0.015
        );

        ctx.fillStyle = theme.dino.spots;
        ctx.fillRect(
          dinoX + dinoW * 0.38,
          dinoY + dinoH * 0.55,
          dinoW * 0.06,
          dinoH * 0.04
        );
        ctx.fillRect(
          dinoX + dinoW * 0.52,
          dinoY + dinoH * 0.65,
          dinoW * 0.05,
          dinoH * 0.04
        );

        ctx.fillStyle = theme.dino.spikes;
        for (let i = 0; i < 4; i++) {
          let x = dinoX + dinoW * (0.32 + i * 0.08);
          let y = dinoY + dinoH * 0.5;
          ctx.fillRect(x, y, dinoW * 0.06, dinoH * 0.04);
          ctx.fillRect(
            x + dinoW * 0.01,
            y - dinoH * 0.04,
            dinoW * 0.04,
            dinoH * 0.04
          );
          ctx.fillRect(
            x + dinoW * 0.02,
            y - dinoH * 0.08,
            dinoW * 0.02,
            dinoH * 0.04
          );
        }

        foods.forEach(food => {
          const fx = food.x;
          const fy = food.y;
          const fw = food.width;
          const fh = food.height;
          ctx.fillStyle = food.color;
          ctx.fillRect(fx + 4, fy + 4, fw - 8, fh - 8);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fillRect(fx + 6, fy + 6, fw * 0.3, fh * 0.2);
          ctx.fillRect(fx + 6, fy + 8, fw * 0.2, fh * 0.3);

          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(fx + fw - 10, fy + fh - 8, fw * 0.2, fh * 0.15);
          ctx.fillRect(fx + fw - 8, fy + fh - 10, fw * 0.15, fh * 0.2);

          ctx.fillStyle = food.color;
          ctx.fillRect(fx + 2, fy + 2, fw - 4, 2);
          ctx.fillRect(fx + 2, fy + fh - 4, fw - 4, 2);
          ctx.fillRect(fx + 2, fy + 2, 2, fh - 4);
          ctx.fillRect(fx + fw - 4, fy + 2, 2, fh - 4);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.fillRect(fx + 4, fy + 4, 2, 2);
          ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.fillRect(fx + fw - 6, fy + fh - 6, 2, 2);
        });

        obstacles.forEach(obstacle => {
          const ox = obstacle.x;
          const oy = obstacle.y;
          const ow = obstacle.width;
          const oh = obstacle.height;

          ctx.fillStyle = theme.cactus.main;
          ctx.fillRect(ox + 6, oy, ow * 0.4, oh);

          ctx.fillStyle = theme.cactus.main;
          ctx.fillRect(ox + 2, oy + oh * 0.3, ow * 0.3, ow * 0.2);
          ctx.fillRect(ox, oy + oh * 0.3, ow * 0.2, oh * 0.4);
          ctx.fillRect(ox + ow * 0.7, oy + oh * 0.4, ow * 0.3, ow * 0.2);
          ctx.fillRect(ox + ow * 0.8, oy + oh * 0.4, ow * 0.2, oh * 0.3);

          ctx.fillStyle = theme.cactus.spikes;
          for (let i = 0; i < 6; i++) {
            let spikeY = oy + (i * oh) / 6 + 2;
            ctx.fillRect(ox + 4, spikeY, 2, 3);
            ctx.fillRect(ox + ow * 0.6, spikeY, 2, 3);
            ctx.fillRect(ox + ow * 0.35, spikeY, 3, 2);
          }

          ctx.fillStyle = theme.cactus.highlight;
          ctx.fillRect(ox + 8, oy + 2, 2, oh - 4);
          ctx.fillStyle = theme.cactus.main;
          ctx.fillRect(ox + 4, oy + oh - 2, ow * 0.6, 2);
        });

        ctx.fillStyle = theme.text;
        ctx.font = 'bold 24px "Courier New", monospace';
        ctx.fillText(`Score: ${score}`, 20, 40);
        const minutes = Math.floor(gameTime / 3600);
        const seconds = Math.floor((gameTime % 3600) / 60);
        ctx.fillText(`Time: ${minutes}m ${seconds}s`, 20, 70);

        let difficulty = 'Easy';
        if (score >= 5000) {
          difficulty = 'Extreme';
        } else if (score >= 3000) {
          difficulty = 'Hard';
        } else if (score >= 1500) {
          difficulty = 'Medium';
        }
        ctx.fillText(`Difficulty: ${difficulty}`, 20, 100);

        ctx.font = '16px "Courier New", monospace';
        ctx.fillStyle = theme.subText;
        ctx.fillText('Press SPACE to jump!', 20, canvas.height - 40);
        ctx.fillText(
          `Press T to toggle ${darkMode ? 'light' : 'dark'} mode`,
          20,
          canvas.height - 20
        );

        if (gameOver) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = '#FF0000';
          ctx.font = 'bold 48px Arial';
          ctx.fillText(
            'GAME OVER!',
            canvas.width / 2 - 150,
            canvas.height / 2 - 50
          );

          ctx.fillStyle = '#FFF';
          ctx.font = '24px Arial';
          ctx.fillText(
            `Final Score: ${score}`,
            canvas.width / 2 - 80,
            canvas.height / 2
          );
          ctx.fillText(
            `Time: ${Math.floor(gameTime / 3600)}m ${Math.floor(
              (gameTime % 3600) / 60
            )}s`,
            canvas.width / 2 - 60,
            canvas.height / 2 + 30
          );

          ctx.font = '18px Arial';
          ctx.fillText(
            'Press R to restart',
            canvas.width / 2 - 70,
            canvas.height / 2 + 80
          );
        }
      }
      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }

      function restartGame() {
        score = 0;
        gameTime = 0;
        gameOver = false;
        gameRunning = true;
        foods.length = 0;
        obstacles.length = 0;
        foodSpawnTimer = 0;
        obstacleSpawnTimer = 0;
        dino.x = 50;
        dino.y = canvas.height - 100 - dino.height;
        dino.velocityY = 0;
        dino.onGround = false;
        dino.jumpsRemaining = dino.maxJumps;
        generateGroundPattern();
      }

      function toggleTheme() {
        darkMode = !darkMode;
        playThemeToggleSound();
        generateGroundPattern();
      }

      document.addEventListener('keydown', e => {
        if (e.code === 'Space' && dino.jumpsRemaining > 0 && !gameOver) {
          dino.velocityY = dino.jumpPower;
          dino.jumpsRemaining--;
          dino.onGround = false;
          playJumpSound();
          e.preventDefault();
        }

        if (e.code === 'KeyR' && gameOver) {
          restartGame();
          e.preventDefault();
        }

        if (e.code === 'KeyT') {
          toggleTheme();
          e.preventDefault();
        }
      });
      init();
    </script>
  </body>
</html>
