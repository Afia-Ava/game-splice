<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris - Game Hub</title>
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="firebase-config.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        background: #000000;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: 'Courier New', monospace;
        color: white;
        position: relative;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
        box-sizing: border-box;
      }

      body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(255, 255, 255, 0.03) 2px,
          rgba(255, 255, 255, 0.03) 4px
        );
        pointer-events: none;
        z-index: 1000;
      }

      #gameCanvas {
        border: 3px solid white;
        background: #000000;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
      }

      .back-button {
        position: absolute;
        top: 20px;
        left: 20px;
        background: black;
        color: white;
        border: 2px solid white;
        padding: 8px 16px;
        border-radius: 0;
        font-size: 12px;
        font-weight: 900;
        cursor: pointer;
        transition: all 0.3s ease;
        text-decoration: none;
        display: inline-block;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-family: 'Courier New', monospace;
        z-index: 1000;
        max-width: calc(100vw - 350px);
      }

      .back-button:hover {
        background: white;
        color: black;
        border: 2px solid black;
      }

      .game-info {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-family: 'Courier New', monospace;
        width: 220px;
        max-width: calc(100vw - 350px);
        z-index: 1000;
      }

      .score {
        font-size: 16px;
        color: white;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border: 2px solid white;
        padding: 15px 20px;
        background: rgba(0, 0, 0, 0.8);
        text-align: left;
      }

      .controls {
        font-size: 11px;
        opacity: 0.9;
        font-family: 'Courier New', monospace;
        text-transform: uppercase;
        letter-spacing: 0.3px;
        color: #ccc;
        line-height: 1.4;
        border: 1px solid #666;
        padding: 15px 20px;
        background: rgba(0, 0, 0, 0.6);
        text-align: left;
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="back-button">Back</a>
    <canvas id="gameCanvas" width="300" height="480"></canvas>
    <div class="game-info">
      <div class="score">
        Score: <span id="score">0</span><br />
        Lines: <span id="lines">0</span>
      </div>
      <div class="controls">
        Arrow keys to move<br />
        Up to rotate<br />
        Down to drop faster
      </div>
    </div>

    <script>
      if (typeof window.firebaseConfig === 'undefined') {
        console.error(
          'Firebase configuration not loaded. Please check firebase-config.js'
        );
      }

      let auth,
        db,
        currentUser = null;
      try {
        firebase.initializeApp(window.firebaseConfig);
        auth = firebase.auth();
        db = firebase.firestore();
        console.log('Firebase initialized successfully');
      } catch (error) {
        console.error('Firebase initialization error:', error);
      }

      auth.onAuthStateChanged(user => {
        currentUser = user;
      });

      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreElement = document.getElementById('score');
      const linesElement = document.getElementById('lines');

      let gameRunning = true;

      let audioContext;
      let masterGain;

      function initAudio() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          masterGain = audioContext.createGain();
          masterGain.gain.value = 0.3;
          masterGain.connect(audioContext.destination);
        }
      }

      function playMoveSound() {
        initAudio();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          200,
          audioContext.currentTime + 0.08
        );

        gainNode.gain.setValueAtTime(0.04, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.08
        );

        oscillator.connect(gainNode);
        gainNode.connect(masterGain);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.08);
      }

      function playRotateSound() {
        initAudio();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(330, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          350,
          audioContext.currentTime + 0.12
        );

        gainNode.gain.setValueAtTime(0.06, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.12
        );

        oscillator.connect(gainNode);
        gainNode.connect(masterGain);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.12);
      }

      function playDropSound() {
        initAudio();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          120,
          audioContext.currentTime + 0.2
        );

        gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.2
        );

        oscillator.connect(gainNode);
        gainNode.connect(masterGain);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
      }

      function playLineClearSound() {
        initAudio();
        const frequencies = [523, 659, 784, 1047];

        frequencies.forEach((freq, index) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(
            freq,
            audioContext.currentTime + index * 0.08
          );

          gainNode.gain.setValueAtTime(
            0.2,
            audioContext.currentTime + index * 0.08
          );
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + index * 0.08 + 0.3
          );

          oscillator.connect(gainNode);
          gainNode.connect(masterGain);

          oscillator.start(audioContext.currentTime + index * 0.08);
          oscillator.stop(audioContext.currentTime + index * 0.08 + 0.3);
        });
      }

      function playGameOverSound() {
        initAudio();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          150,
          audioContext.currentTime + 1.0
        );

        gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 1.0
        );

        oscillator.connect(gainNode);
        gainNode.connect(masterGain);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 1.0);
      }

      const COLS = 10;
      const ROWS = 16;
      const BLOCK_SIZE = 30;

      let board = Array(ROWS)
        .fill()
        .map(() => Array(COLS).fill(0));
      let score = 0;
      let lines = 0;
      let dropTime = 0;
      let lastTime = 0;

      const PIECES = [
        // I piece (horizontal)
        [[1, 1, 1, 1]],
        // I piece (vertical)
        [[1], [1], [1], [1]],
        // T piece
        [
          [0, 1, 0],
          [1, 1, 1],
        ],
        // L piece
        [
          [1, 0, 0],
          [1, 1, 1],
        ],
        // J piece
        [
          [0, 0, 1],
          [1, 1, 1],
        ],
        // S piece
        [
          [0, 1, 1],
          [1, 1, 0],
        ],
        // Z piece
        [
          [1, 1, 0],
          [0, 1, 1],
        ],
        // O piece
        [
          [1, 1],
          [1, 1],
        ],
        // lowercase l
        [
          [1, 0],
          [1, 1],
        ],
        [
          [0, 1],
          [1, 1],
        ],
        // single block piece
        [[1]],
        // horizontal line
        [[1, 1]],
      ];

      const COLORS = [
        '#000',
        '#ff0000',
        '#ff4500',
        '#00ff00',
        '#0000ff',
        '#ffff00',
        '#ff00ff',
        '#00ffff',
        '#ffa500',
        '#ff69b4',
        '#9370db',
        '#20b2aa',
        '#dc143c',
      ];

      let currentPiece = {
        x: 3,
        y: 0,
        shape: [],
        color: 1,
      };

      function createPiece() {
        const pieceIndex = Math.floor(Math.random() * PIECES.length);
        const piece = PIECES[pieceIndex];

        currentPiece = {
          x: 3,
          y: 0,
          shape: piece,
          color: pieceIndex + 1,
        };

        if (collision()) {
          gameRunning = false;
          playGameOverSound();

          if (currentUser && db) {
            console.log('Attempting to submit score:', score);
            submitScore('tetris', score);
          }

          showGameOverScreen();
        }
      }

      function rotatePiece(piece) {
        const rotated = [];
        const rows = piece.length;
        const cols = piece[0].length;

        for (let i = 0; i < cols; i++) {
          rotated[i] = [];
          for (let j = 0; j < rows; j++) {
            rotated[i][j] = piece[rows - 1 - j][i];
          }
        }
        return rotated;
      }

      function collision() {
        for (let row = 0; row < currentPiece.shape.length; row++) {
          for (let col = 0; col < currentPiece.shape[row].length; col++) {
            if (currentPiece.shape[row][col]) {
              const newX = currentPiece.x + col;
              const newY = currentPiece.y + row;

              if (newX < 0 || newX >= COLS || newY >= ROWS) {
                return true;
              }

              if (newY >= 0 && board[newY][newX] !== 0) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function merge() {
        for (let row = 0; row < currentPiece.shape.length; row++) {
          for (let col = 0; col < currentPiece.shape[row].length; col++) {
            if (currentPiece.shape[row][col]) {
              const boardX = currentPiece.x + col;
              const boardY = currentPiece.y + row;
              if (boardY >= 0) {
                board[boardY][boardX] = currentPiece.color;
              }
            }
          }
        }

        for (let row = ROWS - 1; row >= 0; row--) {
          if (board[row].every(cell => cell !== 0)) {
            board.splice(row, 1);
            board.unshift(Array(COLS).fill(0));
            lines++;
            score += 100;
            linesElement.textContent = lines;
            scoreElement.textContent = score;
            playLineClearSound();
            row++;
          }
        }
      }

      function draw() {
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            if (board[row][col]) {
              ctx.fillStyle = COLORS[board[row][col]];
              ctx.fillRect(
                col * BLOCK_SIZE,
                row * BLOCK_SIZE,
                BLOCK_SIZE - 1,
                BLOCK_SIZE - 1
              );

              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 1;
              ctx.strokeRect(
                col * BLOCK_SIZE,
                row * BLOCK_SIZE,
                BLOCK_SIZE - 1,
                BLOCK_SIZE - 1
              );
            }
          }
        }

        drawPiece(currentPiece);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        for (let i = 0; i <= COLS; i++) {
          ctx.beginPath();
          ctx.moveTo(i * BLOCK_SIZE, 0);
          ctx.lineTo(i * BLOCK_SIZE, canvas.height);
          ctx.stroke();
        }
        for (let i = 0; i <= ROWS; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * BLOCK_SIZE);
          ctx.lineTo(canvas.width, i * BLOCK_SIZE);
          ctx.stroke();
        }
      }

      function drawPiece(piece) {
        ctx.fillStyle = COLORS[piece.color];
        for (let row = 0; row < piece.shape.length; row++) {
          for (let col = 0; col < piece.shape[row].length; col++) {
            if (piece.shape[row][col]) {
              const x = (piece.x + col) * BLOCK_SIZE;
              const y = (piece.y + row) * BLOCK_SIZE;

              ctx.fillRect(x, y, BLOCK_SIZE - 1, BLOCK_SIZE - 1);

              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.strokeRect(x, y, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            }
          }
        }
      }

      function update(time = 0) {
        if (!gameRunning) return;

        const deltaTime = time - lastTime;
        lastTime = time;
        dropTime += deltaTime;

        if (dropTime > 1000) {
          currentPiece.y++;
          if (collision()) {
            currentPiece.y--;
            merge();
            playDropSound();
            createPiece();
          }
          dropTime = 0;
        }
        draw();
        requestAnimationFrame(update);
      }

      document.addEventListener('keydown', e => {
        if (!gameRunning) return;

        switch (e.key) {
          case 'ArrowLeft':
            currentPiece.x--;
            if (collision()) {
              currentPiece.x++;
            } else {
              playMoveSound();
            }
            break;
          case 'ArrowRight':
            currentPiece.x++;
            if (collision()) {
              currentPiece.x--;
            } else {
              playMoveSound();
            }
            break;
          case 'ArrowDown':
            currentPiece.y++;
            if (collision()) {
              currentPiece.y--;
              merge();
              playDropSound();
              createPiece();
            } else {
              playMoveSound();
            }
            break;
          case 'ArrowUp':
            const originalShape = currentPiece.shape;
            currentPiece.shape = rotatePiece(currentPiece.shape);
            if (collision()) {
              currentPiece.shape = originalShape;
            } else {
              playRotateSound();
            }
            break;
        }
      });

      function showGameOverScreen() {
        const gameOverDiv = document.createElement('div');
        gameOverDiv.id = 'gameOverScreen';
        gameOverDiv.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.9);
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          font-family: 'Courier New', monospace;
          color: white;
          z-index: 1000;
        `;

        gameOverDiv.innerHTML = `
          <h1 style="font-size: 4rem; color: #ff0000; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 3px;">GAME OVER</h1>
          <h2 style="font-size: 2rem; color: #00ff00; margin-bottom: 10px;">Final Score: ${score}</h2>
          <h3 style="font-size: 1.5rem; color: #ffff00; margin-bottom: 30px;">Lines Cleared: ${lines}</h3>
          <button id="playAgainBtn" style="
            background: black;
            color: white;
            border: 2px solid white;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
          ">🧩 Play Again</button>
          <button id="backToMenuBtn" style="
            background: black;
            color: white;
            border: 2px solid white;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
          ">🏠 Back to Menu</button>
          <button id="viewLeaderboardBtn" style="
            background: black;
            color: white;
            border: 2px solid #00ff00;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
          ">🏆 View Leaderboard</button>
        `;

        document.body.appendChild(gameOverDiv);

        const playAgainBtn = document.getElementById('playAgainBtn');
        const backToMenuBtn = document.getElementById('backToMenuBtn');
        const viewLeaderboardBtn =
          document.getElementById('viewLeaderboardBtn');

        [playAgainBtn, backToMenuBtn, viewLeaderboardBtn].forEach(btn => {
          btn.addEventListener('mouseenter', () => {
            btn.style.background = 'white';
            btn.style.color = 'black';
          });
          btn.addEventListener('mouseleave', () => {
            btn.style.background = 'black';
            btn.style.color = 'white';
          });
        });

        playAgainBtn.addEventListener('click', () => {
          document.body.removeChild(gameOverDiv);
          resetGame();
          gameRunning = true;
          update();
        });

        backToMenuBtn.addEventListener('click', () => {
          window.location.href = 'index.html';
        });

        viewLeaderboardBtn.addEventListener('click', () => {
          window.location.href = 'index.html#leaderboard';
        });
      }

      function resetGame() {
        board = Array(ROWS)
          .fill()
          .map(() => Array(COLS).fill(0));
        score = 0;
        lines = 0;
        scoreElement.textContent = score;
        linesElement.textContent = lines;
        dropTime = 0;
        lastTime = 0;
        createPiece();
      }

      async function submitScore(gameName, finalScore) {
        console.log('=== SCORE SUBMISSION DEBUG ===');
        console.log('submitScore called with:', gameName, finalScore);
        console.log('Current user:', currentUser);
        console.log('Database available:', !!db);
        console.log('Auth state:', auth.currentUser);

        if (!currentUser || !db) {
          console.log(
            '❌ User not logged in or Firebase not available - score not submitted'
          );
          return;
        }

        try {
          console.log('✅ Submitting score to Firebase...');

          const numericScore =
            typeof finalScore === 'number'
              ? finalScore
              : parseInt(finalScore) || 0;

          const scoreDoc = await db
            .collection('leaderboards')
            .doc(gameName)
            .collection('scores')
            .add({
              userId: currentUser.uid,
              username:
                currentUser.displayName || currentUser.email.split('@')[0],
              score: numericScore,
              lines: lines,
              timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            });

          console.log('✅ Score document written:', scoreDoc.id);

          const userRef = db.collection('users').doc(currentUser.uid);
          const userDoc = await userRef.get();

          if (userDoc.exists) {
            const userData = userDoc.data();
            const personalBests = userData.personalBests || {};

            if (
              !personalBests[gameName] ||
              numericScore > personalBests[gameName]
            ) {
              personalBests[gameName] = numericScore;
              await userRef.update({ personalBests: personalBests });
              console.log('✅ Personal best updated to:', numericScore);
            }
          } else {
            await userRef.set({
              personalBests: { [gameName]: numericScore },
            });
            console.log(
              '✅ New user document created with personal best:',
              numericScore
            );
          }

          console.log('✅ Score submitted successfully:', numericScore);
        } catch (error) {
          console.error('❌ Error submitting score:', error);
          console.error('Error code:', error.code);
          console.error('Error message:', error.message);
        }
      }

      createPiece();
      update();

      document.addEventListener('click', initAudio, { once: true });
      document.addEventListener('keydown', initAudio, { once: true });
    </script>
  </body>
</html>
