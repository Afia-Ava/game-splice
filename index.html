<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jumpasaurus - Dinosaur Food Collector</title>
    <style>
      body {
        margin: 0;
        padding: 10px;
        background: #222;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: Arial, sans-serif;
        overflow: hidden;
        box-sizing: border-box;
      }
      #gameCanvas {
        border: 3px solid #444;
        background: #87ceeb;
        max-width: 95vw;
        max-height: 90vh;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="1200" height="600"></canvas>
    <script>
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      let score = 0;
      let gameTime = 0;
      const dino = {
        x: 50,
        y: 300,
        width: 50,
        height: 50,
        velocityY: 0,
        gravity: 0.8,
        jumpPower: -15,
        onGround: false,
        jumpsRemaining: 5,
        maxJumps: 5,
      };

      const foods = [];
      let foodSpawnTimer = 0;
      let groundPattern = [];
      const obstacles = [];
      let obstacleSpawnTimer = 0;
      let gameOver = false;
      let darkMode = true;

      const themes = {
        dark: {
          sky: '#1a1a2e',
          ground: '#2d2d44',
          groundBlocks: ['#4a4a5e', '#3a3a4a'],
          grass: ['#3d5a3d', '#4a6b4a'],
          dino: {
            main: '#4a6741',
            legs: '#3a5038',
            feet: '#2a3a28',
            spots: '#3a5038',
            spikes: '#5a7c57',
          },
          cactus: {
            main: '#4a5c4a',
            spikes: '#2a3a2a',
            highlight: '#6a7c6a',
          },
          text: '#FFF',
          subText: '#CCC',
          food: ['#ff8a8a', '#8ac4ff', '#85c1ff', '#b6d4b6', '#ffdf8a'],
        },
        light: {
          sky: '#87CEEB',
          ground: '#8B4513',
          groundBlocks: ['#A0522D', '#654321'],
          grass: ['#228B22', '#32CD32'],
          dino: {
            main: '#228B22',
            legs: '#1F5F1F',
            feet: '#0F3F0F',
            spots: '#1F5F1F',
            spikes: '#32CD32',
          },
          cactus: {
            main: '#2F4F2F',
            spikes: '#1C3A1C',
            highlight: '#4F6F4F',
          },
          text: '#000',
          subText: '#FFF',
          food: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'],
        },
      };

      function getCurrentTheme() {
        return darkMode ? themes.dark : themes.light;
      }

      const foodTypes = [
        { color: getCurrentTheme().food[0], points: 50 },
        { color: getCurrentTheme().food[1], points: 75 },
        { color: getCurrentTheme().food[2], points: 100 },
        { color: getCurrentTheme().food[3], points: 125 },
        { color: getCurrentTheme().food[4], points: 150 },
      ];

      function generateGroundPattern() {
        groundPattern = [];
        for (let x = 0; x < canvas.width; x += 20) {
          for (let y = canvas.height - 100; y < canvas.height; y += 20) {
            if (Math.random() > 0.6) {
              groundPattern.push({ x: x, y: y, size: 20, color: '#A0522D' });
            }
          }
        }

        for (let x = 0; x < canvas.width; x += 15) {
          for (let y = canvas.height - 80; y < canvas.height; y += 15) {
            if (Math.random() > 0.7) {
              groundPattern.push({ x: x, y: y, size: 15, color: '#654321' });
            }
          }
        }

        for (let x = 0; x < canvas.width; x += 10) {
          let grassColors = getCurrentTheme().grass;
          let grassColor =
            Math.random() > 0.5 ? grassColors[0] : grassColors[1];
          let grassHeight = Math.floor(Math.random() * 8) + 12;
          groundPattern.push({
            x: x,
            y: canvas.height - 100,
            width: 10,
            height: grassHeight,
            color: grassColor,
            isGrass: true,
          });
        }
      }

      function init() {
        dino.y = canvas.height - 100 - dino.height;
        generateGroundPattern();
        gameLoop();
      }
      function spawnFood() {
        const foodColors = getCurrentTheme().food;
        const foodTypes = [
          { color: foodColors[0], points: 50 },
          { color: foodColors[1], points: 75 },
          { color: foodColors[2], points: 100 },
          { color: foodColors[3], points: 125 },
          { color: foodColors[4], points: 150 },
        ];
        const foodType =
          foodTypes[Math.floor(Math.random() * foodTypes.length)];
        foods.push({
          x: canvas.width,
          y: Math.random() * (canvas.height - 300) + 100,
          width: 30,
          height: 30,
          color: foodType.color,
          points: foodType.points,
          speed: 3 + Math.random() * 2,
        });
      }

      function spawnObstacle() {
        // Increase speed based on score for higher difficulty
        let baseSpeed = 3;
        let speedMultiplier = 1;

        if (score >= 5000) {
          speedMultiplier = 2.5;
        } else if (score >= 3000) {
          speedMultiplier = 2;
        } else if (score >= 1000) {
          speedMultiplier = 1.5;
        }

        obstacles.push({
          x: canvas.width,
          y: canvas.height - 100 - 40,
          width: 20,
          height: 40,
          speed: (baseSpeed + Math.random() * 1.5) * speedMultiplier,
        });
      }

      function update() {
        if (gameOver) return;

        gameTime++;

        dino.velocityY += dino.gravity;
        dino.y += dino.velocityY;
        const groundY = canvas.height - 100;
        if (dino.y + dino.height >= groundY) {
          dino.y = groundY - dino.height;
          dino.velocityY = 0;
          dino.onGround = true;
          dino.jumpsRemaining = dino.maxJumps;
        } else {
          dino.onGround = false;
        }

        if (dino.y < 0) {
          dino.y = 0;
          dino.velocityY = 0;
        }

        foodSpawnTimer++;
        if (foodSpawnTimer >= 60) {
          spawnFood();
          foodSpawnTimer = 0;
        }

        obstacleSpawnTimer++;

        // Dynamic obstacle spawn rate based on score
        let obstacleSpawnRate = 180; // Default: every 3 seconds at 60fps

        if (score >= 5000) {
          obstacleSpawnRate = 90; // Every 1.5 seconds
        } else if (score >= 3000) {
          obstacleSpawnRate = 120; // Every 2 seconds
        } else if (score >= 1500) {
          obstacleSpawnRate = 150; // Every 2.5 seconds
        }

        if (obstacleSpawnTimer >= obstacleSpawnRate) {
          spawnObstacle();
          obstacleSpawnTimer = 0;
        }

        for (let i = foods.length - 1; i >= 0; i--) {
          const food = foods[i];
          food.x -= food.speed;

          if (
            dino.x < food.x + food.width &&
            dino.x + dino.width > food.x &&
            dino.y < food.y + food.height &&
            dino.y + dino.height > food.y
          ) {
            score += food.points;
            foods.splice(i, 1);
            continue;
          }

          if (food.x + food.width < 0) {
            foods.splice(i, 1);
          }
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obstacle = obstacles[i];
          obstacle.x -= obstacle.speed;

          if (
            dino.x < obstacle.x + obstacle.width &&
            dino.x + dino.width > obstacle.x &&
            dino.y < obstacle.y + obstacle.height &&
            dino.y + dino.height > obstacle.y
          ) {
            gameOver = true;
            break;
          }

          if (obstacle.x + obstacle.width < 0) {
            obstacles.splice(i, 1);
          }
        }
      }

      function draw() {
        const theme = getCurrentTheme();

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = theme.sky;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = theme.ground;
        ctx.fillRect(0, canvas.height - 100, canvas.width, 100);

        groundPattern.forEach(block => {
          if (block.isGrass) {
            ctx.fillStyle = block.color;
            ctx.fillRect(block.x, block.y, block.width, block.height);
          } else {
            let darkColor =
              block.color === '#A0522D'
                ? theme.groundBlocks[0]
                : theme.groundBlocks[1];
            ctx.fillStyle = darkColor;
            ctx.fillRect(block.x, block.y, block.size, block.size);
          }
        });

        const dinoX = dino.x;
        const dinoY = dino.y;
        const dinoW = dino.width;
        const dinoH = dino.height;

        ctx.fillStyle = theme.dino.main;
        ctx.fillRect(
          dinoX + dinoW * 0.3,
          dinoY + dinoH * 0.5,
          dinoW * 0.4,
          dinoH * 0.3
        );

        ctx.fillStyle = theme.dino.main;
        ctx.fillRect(
          dinoX + dinoW * 0.65,
          dinoY + dinoH * 0.35,
          dinoW * 0.1,
          dinoH * 0.2
        );
        ctx.fillRect(
          dinoX + dinoW * 0.7,
          dinoY + dinoH * 0.25,
          dinoW * 0.08,
          dinoH * 0.15
        );

        ctx.fillStyle = theme.dino.main;
        ctx.fillRect(
          dinoX + dinoW * 0.75,
          dinoY + dinoH * 0.15,
          dinoW * 0.15,
          dinoH * 0.12
        );

        ctx.fillStyle = theme.dino.main;
        ctx.fillRect(
          dinoX + dinoW * 0.88,
          dinoY + dinoH * 0.2,
          dinoW * 0.08,
          dinoH * 0.06
        );

        ctx.fillStyle = theme.dino.main;
        ctx.fillRect(
          dinoX + dinoW * 0.1,
          dinoY + dinoH * 0.65,
          dinoW * 0.25,
          dinoH * 0.1
        );
        ctx.fillRect(
          dinoX - dinoW * 0.05,
          dinoY + dinoH * 0.68,
          dinoW * 0.18,
          dinoH * 0.08
        );
        ctx.fillRect(
          dinoX - dinoW * 0.15,
          dinoY + dinoH * 0.7,
          dinoW * 0.12,
          dinoH * 0.06
        );

        ctx.fillStyle = theme.dino.legs;
        ctx.fillRect(
          dinoX + dinoW * 0.35,
          dinoY + dinoH * 0.8,
          dinoW * 0.08,
          dinoH * 0.25
        );
        ctx.fillRect(
          dinoX + dinoW * 0.5,
          dinoY + dinoH * 0.8,
          dinoW * 0.08,
          dinoH * 0.25
        );

        ctx.fillStyle = theme.dino.feet;
        ctx.fillRect(
          dinoX + dinoW * 0.32,
          dinoY + dinoH * 1.0,
          dinoW * 0.14,
          dinoH * 0.08
        );
        ctx.fillRect(
          dinoX + dinoW * 0.47,
          dinoY + dinoH * 1.0,
          dinoW * 0.14,
          dinoH * 0.08
        );

        ctx.fillStyle = theme.dino.legs;
        ctx.fillRect(
          dinoX + dinoW * 0.65,
          dinoY + dinoH * 0.55,
          dinoW * 0.04,
          dinoH * 0.1
        );

        ctx.fillStyle = '#000';
        ctx.fillRect(
          dinoX + dinoW * 0.8,
          dinoY + dinoH * 0.18,
          dinoW * 0.04,
          dinoH * 0.03
        );

        ctx.fillStyle = '#FFF';
        ctx.fillRect(
          dinoX + dinoW * 0.82,
          dinoY + dinoH * 0.185,
          dinoW * 0.015,
          dinoH * 0.015
        );

        ctx.fillStyle = '#000';
        ctx.fillRect(
          dinoX + dinoW * 0.9,
          dinoY + dinoH * 0.22,
          dinoW * 0.02,
          dinoH * 0.015
        );

        ctx.fillStyle = theme.dino.spots;
        ctx.fillRect(
          dinoX + dinoW * 0.38,
          dinoY + dinoH * 0.55,
          dinoW * 0.06,
          dinoH * 0.04
        );
        ctx.fillRect(
          dinoX + dinoW * 0.52,
          dinoY + dinoH * 0.65,
          dinoW * 0.05,
          dinoH * 0.04
        );

        ctx.fillStyle = theme.dino.spikes;
        for (let i = 0; i < 4; i++) {
          let x = dinoX + dinoW * (0.32 + i * 0.08);
          let y = dinoY + dinoH * 0.5;
          ctx.fillRect(x, y, dinoW * 0.06, dinoH * 0.04);
          ctx.fillRect(
            x + dinoW * 0.01,
            y - dinoH * 0.04,
            dinoW * 0.04,
            dinoH * 0.04
          );
          ctx.fillRect(
            x + dinoW * 0.02,
            y - dinoH * 0.08,
            dinoW * 0.02,
            dinoH * 0.04
          );
        }

        foods.forEach(food => {
          const fx = food.x;
          const fy = food.y;
          const fw = food.width;
          const fh = food.height;
          ctx.fillStyle = food.color;
          ctx.fillRect(fx + 4, fy + 4, fw - 8, fh - 8);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fillRect(fx + 6, fy + 6, fw * 0.3, fh * 0.2);
          ctx.fillRect(fx + 6, fy + 8, fw * 0.2, fh * 0.3);

          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(fx + fw - 10, fy + fh - 8, fw * 0.2, fh * 0.15);
          ctx.fillRect(fx + fw - 8, fy + fh - 10, fw * 0.15, fh * 0.2);

          ctx.fillStyle = food.color;
          ctx.fillRect(fx + 2, fy + 2, fw - 4, 2);
          ctx.fillRect(fx + 2, fy + fh - 4, fw - 4, 2);
          ctx.fillRect(fx + 2, fy + 2, 2, fh - 4);
          ctx.fillRect(fx + fw - 4, fy + 2, 2, fh - 4);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.fillRect(fx + 4, fy + 4, 2, 2);
          ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.fillRect(fx + fw - 6, fy + fh - 6, 2, 2);
        });

        obstacles.forEach(obstacle => {
          const ox = obstacle.x;
          const oy = obstacle.y;
          const ow = obstacle.width;
          const oh = obstacle.height;

          ctx.fillStyle = theme.cactus.main;
          ctx.fillRect(ox + 6, oy, ow * 0.4, oh);

          ctx.fillStyle = theme.cactus.main;
          ctx.fillRect(ox + 2, oy + oh * 0.3, ow * 0.3, ow * 0.2);
          ctx.fillRect(ox, oy + oh * 0.3, ow * 0.2, oh * 0.4);
          ctx.fillRect(ox + ow * 0.7, oy + oh * 0.4, ow * 0.3, ow * 0.2);
          ctx.fillRect(ox + ow * 0.8, oy + oh * 0.4, ow * 0.2, oh * 0.3);

          ctx.fillStyle = theme.cactus.spikes;
          for (let i = 0; i < 6; i++) {
            let spikeY = oy + (i * oh) / 6 + 2;
            ctx.fillRect(ox + 4, spikeY, 2, 3);
            ctx.fillRect(ox + ow * 0.6, spikeY, 2, 3);
            ctx.fillRect(ox + ow * 0.35, spikeY, 3, 2);
          }

          ctx.fillStyle = theme.cactus.highlight;
          ctx.fillRect(ox + 8, oy + 2, 2, oh - 4);

          ctx.fillStyle = theme.cactus.main;
          ctx.fillRect(ox + 4, oy + oh - 2, ow * 0.6, 2);
        });

        ctx.fillStyle = theme.text;
        ctx.font = 'bold 24px Arial';
        ctx.fillText(`Score: ${score}`, 20, 40);
        const minutes = Math.floor(gameTime / 3600);
        const seconds = Math.floor((gameTime % 3600) / 60);
        ctx.fillText(`Time: ${minutes}m ${seconds}s`, 20, 70);

        // Display difficulty level
        let difficulty = 'Easy';
        if (score >= 5000) {
          difficulty = 'Extreme';
        } else if (score >= 3000) {
          difficulty = 'Hard';
        } else if (score >= 1500) {
          difficulty = 'Medium';
        }
        ctx.fillText(`Difficulty: ${difficulty}`, 20, 100);

        ctx.font = '16px Arial';
        ctx.fillStyle = theme.subText;
        ctx.fillText('Press SPACE to jump!', 20, canvas.height - 40);
        ctx.fillText(
          `Press T to toggle ${darkMode ? 'light' : 'dark'} mode`,
          20,
          canvas.height - 20
        );

        if (gameOver) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = '#FF0000';
          ctx.font = 'bold 48px Arial';
          ctx.fillText(
            'GAME OVER!',
            canvas.width / 2 - 150,
            canvas.height / 2 - 50
          );

          ctx.fillStyle = '#FFF';
          ctx.font = '24px Arial';
          ctx.fillText(
            `Final Score: ${score}`,
            canvas.width / 2 - 80,
            canvas.height / 2
          );
          ctx.fillText(
            `Time: ${Math.floor(gameTime / 3600)}m ${Math.floor(
              (gameTime % 3600) / 60
            )}s`,
            canvas.width / 2 - 60,
            canvas.height / 2 + 30
          );

          ctx.font = '18px Arial';
          ctx.fillText(
            'Press R to restart',
            canvas.width / 2 - 70,
            canvas.height / 2 + 80
          );
        }
      }
      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }

      function restartGame() {
        score = 0;
        gameTime = 0;
        gameOver = false;
        foods.length = 0;
        obstacles.length = 0;
        foodSpawnTimer = 0;
        obstacleSpawnTimer = 0;
        dino.x = 50;
        dino.y = canvas.height - 100 - dino.height;
        dino.velocityY = 0;
        dino.onGround = false;
        dino.jumpsRemaining = dino.maxJumps;
        generateGroundPattern();
      }

      function toggleTheme() {
        darkMode = !darkMode;
        generateGroundPattern();
      }

      document.addEventListener('keydown', e => {
        if (e.code === 'Space' && dino.jumpsRemaining > 0 && !gameOver) {
          dino.velocityY = dino.jumpPower;
          dino.jumpsRemaining--;
          dino.onGround = false;
          e.preventDefault();
        }

        if (e.code === 'KeyR' && gameOver) {
          restartGame();
          e.preventDefault();
        }

        if (e.code === 'KeyT') {
          toggleTheme();
          e.preventDefault();
        }
      });
      init();
    </script>
  </body>
</html>
