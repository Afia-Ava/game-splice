<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dot Muncher - Game Hub</title>
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="firebase-config.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        background: #000000;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: 'Courier New', monospace;
        color: white;
        overflow: hidden;
      }

      .back-button {
        position: absolute;
        top: 20px;
        left: 20px;
        background: black;
        color: white;
        border: 2px solid white;
        padding: 10px 20px;
        text-decoration: none;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.3s ease;
        z-index: 1000;
      }

      .back-button:hover {
        background: white;
        color: black;
        border: 2px solid black;
      }

      .game-container {
        display: flex;
        gap: 20px;
        align-items: center;
        justify-content: center;
        margin-top: -20px;
        position: relative;
      }

      #gameCanvas {
        border: 2px solid white;
        background: #000033;
      }

      .game-info {
        position: fixed;
        top: 15px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        z-index: 100;
      }

      .score {
        background: #000000;
        border: 2px solid white;
        padding: 6px 8px;
        text-align: left;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        min-width: 90px;
        font-size: 0.7rem;
        line-height: 1.2;
      }

      .controls {
        background: #000000;
        border: 2px solid white;
        padding: 5px 6px;
        font-family: 'Courier New', monospace;
        font-size: 0.6rem;
        line-height: 1.2;
        text-transform: uppercase;
        letter-spacing: 1px;
        min-width: 90px;
      }

      .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid white;
        padding: 40px;
        text-align: center;
        font-family: 'Courier New', monospace;
        color: white;
        z-index: 1000;
        display: none;
      }

      .game-over h2 {
        font-size: 2rem;
        margin-bottom: 20px;
        color: #ff0000;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .game-over button {
        background: black;
        color: white;
        border: 2px solid white;
        padding: 15px 30px;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: 20px;
      }

      .game-over button:hover {
        background: white;
        color: black;
      }

      @media (max-width: 768px) {
        .game-container {
          flex-direction: column;
          align-items: center;
        }

        #gameCanvas {
          width: 90vw;
          height: auto;
        }

        .game-info {
          position: fixed;
          top: 8px;
          right: 5px;
          gap: 4px;
        }

        .score,
        .controls {
          min-width: 75px;
          font-size: 0.6rem;
          padding: 4px 5px;
        }

        .controls {
          font-size: 0.55rem;
          padding: 3px 4px;
        }
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="back-button">Back</a>

    <div class="game-container">
      <canvas id="gameCanvas" width="600" height="460"></canvas>
      <div class="game-info">
        <div class="score">
          Score: <span id="score">0</span><br />
          Lives: <span id="lives">3</span><br />
          Level: <span id="level">1</span>
        </div>
        <div class="controls">
          Arrow keys to move<br />
          Collect all dots<br />
          Avoid the ghosts!<br />
          Power pellets make ghosts vulnerable
        </div>
      </div>
    </div>

    <div class="game-over" id="gameOver">
      <h2>Game Over!</h2>
      <p>Final Score: <span id="finalScore">0</span></p>
      <button onclick="restartGame()">Play Again</button>
    </div>

    <script>
      if (typeof window.firebaseConfig === 'undefined') {
        console.error(
          'Firebase configuration not loaded. Please check firebase-config.js'
        );
      }

      let auth,
        db,
        currentUser = null;
      try {
        firebase.initializeApp(window.firebaseConfig);
        auth = firebase.auth();
        db = firebase.firestore();
        console.log('Firebase initialized successfully in Dot Muncher');
      } catch (error) {
        console.error('Firebase initialization error in Dot Muncher:', error);
      }

      auth.onAuthStateChanged(user => {
        currentUser = user;
      });

      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreElement = document.getElementById('score');
      const livesElement = document.getElementById('lives');
      const levelElement = document.getElementById('level');
      const gameOverElement = document.getElementById('gameOver');
      const finalScoreElement = document.getElementById('finalScore');

      let audioContext;
      let masterGain;

      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          masterGain = audioContext.createGain();
          masterGain.gain.value = 0.3;
          masterGain.connect(audioContext.destination);
        } catch (e) {
          console.log('Web Audio API not supported');
        }
      }

      function playDotSound() {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(masterGain);
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          400,
          audioContext.currentTime + 0.1
        );
        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.1
        );
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
      }

      function playPowerPelletSound() {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(masterGain);
        oscillator.type = 'sawtooth';
        oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          600,
          audioContext.currentTime + 0.3
        );

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1000, audioContext.currentTime);
        filter.frequency.exponentialRampToValueAtTime(
          2000,
          audioContext.currentTime + 0.3
        );

        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.3
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      }

      function playGhostEatSound() {
        if (!audioContext) return;
        const notes = [523.25, 659.25, 783.99, 1046.5];
        notes.forEach((freq, index) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(masterGain);
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(
            freq,
            audioContext.currentTime + index * 0.08
          );
          gainNode.gain.setValueAtTime(
            0.15,
            audioContext.currentTime + index * 0.08
          );
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + index * 0.08 + 0.2
          );
          oscillator.start(audioContext.currentTime + index * 0.08);
          oscillator.stop(audioContext.currentTime + index * 0.08 + 0.2);
        });
      }

      function playDeathSound() {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(masterGain);
        oscillator.type = 'sawtooth';
        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          100,
          audioContext.currentTime + 0.8
        );

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1500, audioContext.currentTime);
        filter.frequency.exponentialRampToValueAtTime(
          200,
          audioContext.currentTime + 0.8
        );

        gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.8
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.8);
      }

      function playLevelCompleteSound() {
        if (!audioContext) return;
        const melody = [
          523.25, 587.33, 659.25, 698.46, 783.99, 880.0, 987.77, 1046.5,
        ];

        melody.forEach((freq, index) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(masterGain);
          oscillator.type = 'triangle';
          oscillator.frequency.setValueAtTime(
            freq,
            audioContext.currentTime + index * 0.1
          );

          gainNode.gain.setValueAtTime(
            0.12,
            audioContext.currentTime + index * 0.1
          );
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + index * 0.1 + 0.3
          );

          oscillator.start(audioContext.currentTime + index * 0.1);
          oscillator.stop(audioContext.currentTime + index * 0.1 + 0.3);
        });
      }

      function playGameOverSound() {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(masterGain);
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          150,
          audioContext.currentTime + 1.5
        );

        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 1.5
        );
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 1.5);
      }

      let audioInitialized = false;
      document.addEventListener('click', () => {
        if (!audioInitialized) {
          initAudio();
          audioInitialized = true;
        }
      });

      document.addEventListener('keydown', () => {
        if (!audioInitialized) {
          initAudio();
          audioInitialized = true;
        }
      });

      const CELL_SIZE = 20;
      const COLS = canvas.width / CELL_SIZE;
      const ROWS = 23;

      let score = 0;
      let lives = 3;
      let level = 1;
      let gameRunning = true;
      let powerMode = false;
      let powerModeTimer = 0;
      const maze = [
        [
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1,
          2, 1, 1, 1, 1, 3, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,
          2, 1, 1, 1, 1, 2, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
          2, 1, 1, 1, 1, 1, 1,
        ],
        [
          0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
          2, 1, 0, 0, 0, 0, 0,
        ],
        [
          0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1,
          2, 1, 0, 0, 0, 0, 0,
        ],
        [
          1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
          2, 1, 1, 1, 1, 1, 1,
        ],
        [
          0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
          2, 0, 0, 0, 0, 0, 0,
        ],
        [
          1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
          2, 1, 1, 1, 1, 1, 1,
        ],
        [
          0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1,
          2, 1, 0, 0, 0, 0, 0,
        ],
        [
          0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
          2, 1, 0, 0, 0, 0, 0,
        ],
        [
          1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
          2, 1, 1, 1, 1, 1, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1,
          2, 1, 1, 1, 1, 2, 1,
        ],
        [
          1, 3, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 1, 1, 2, 2, 3, 1,
        ],
        [
          1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,
          2, 1, 1, 2, 1, 1, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 2, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1,
        ],
      ];

      const player = {
        x: 15,
        y: 15,
        direction: 0,
        nextDirection: 0,
        mouthOpen: true,
      };

      const ghosts = [
        { x: 14, y: 9, direction: 0, color: '#ff0000', vulnerable: false },
        { x: 13, y: 9, direction: 1, color: '#ffb8ff', vulnerable: false },
        { x: 15, y: 9, direction: 2, color: '#00ffff', vulnerable: false },
        { x: 14, y: 10, direction: 3, color: '#ffb852', vulnerable: false },
      ];

      const directions = [
        { x: 1, y: 0 },
        { x: 0, y: 1 },
        { x: -1, y: 0 },
        { x: 0, y: -1 },
      ];

      let totalDots = 0;
      let dotsEaten = 0;
      for (let row = 0; row < maze.length; row++) {
        for (let col = 0; col < maze[row].length; col++) {
          if (maze[row][col] === 2 || maze[row][col] === 3) {
            totalDots++;
          }
        }
      }

      const keys = {};
      document.addEventListener('keydown', e => {
        keys[e.key] = true;

        switch (e.key) {
          case 'ArrowRight':
            player.nextDirection = 0;
            break;
          case 'ArrowDown':
            player.nextDirection = 1;
            break;
          case 'ArrowLeft':
            player.nextDirection = 2;
            break;
          case 'ArrowUp':
            player.nextDirection = 3;
            break;
        }
        e.preventDefault();
      });

      document.addEventListener('keyup', e => {
        keys[e.key] = false;
      });

      function canMove(x, y) {
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
        return maze[y][x] !== 1;
      }

      function updatePlayer() {
        if (!gameRunning) return;
        const nextDir = directions[player.nextDirection];
        const nextX = player.x + nextDir.x;
        const nextY = player.y + nextDir.y;

        if (canMove(nextX, nextY)) {
          player.direction = player.nextDirection;
        }

        const dir = directions[player.direction];
        const newX = player.x + dir.x;
        const newY = player.y + dir.y;

        if (canMove(newX, newY)) {
          player.x = newX;
          player.y = newY;

          if (player.x < 0) player.x = COLS - 1;
          if (player.x >= COLS) player.x = 0;
          if (maze[player.y][player.x] === 2) {
            maze[player.y][player.x] = 0;
            score += 10;
            dotsEaten++;
            playDotSound();
          } else if (maze[player.y][player.x] === 3) {
            maze[player.y][player.x] = 0;
            score += 50;
            dotsEaten++;
            playPowerPelletSound();
            activatePowerMode();
          }
          if (dotsEaten >= totalDots) {
            playLevelCompleteSound();
            nextLevel();
          }
        }
        player.mouthOpen = !player.mouthOpen;
      }

      function activatePowerMode() {
        powerMode = true;
        powerModeTimer = 300;
        ghosts.forEach(ghost => {
          ghost.vulnerable = true;
        });
      }

      function updateGhosts() {
        if (!gameRunning) return;

        ghosts.forEach(ghost => {
          if (Math.random() < 0.05) {
            ghost.direction = Math.floor(Math.random() * 4);
          }

          const dir = directions[ghost.direction];
          const newX = ghost.x + dir.x;
          const newY = ghost.y + dir.y;

          if (canMove(newX, newY)) {
            ghost.x = newX;
            ghost.y = newY;

            if (ghost.x < 0) ghost.x = COLS - 1;
            if (ghost.x >= COLS) ghost.x = 0;
          } else {
            ghost.direction = Math.floor(Math.random() * 4);
          }

          if (ghost.x === player.x && ghost.y === player.y) {
            if (powerMode && ghost.vulnerable) {
              score += 200;
              playGhostEatSound();
              ghost.x = 14;
              ghost.y = 9;
              ghost.vulnerable = false;
            } else {
              lives--;
              playDeathSound();
              resetPositions();
              if (lives <= 0) {
                gameOver();
              }
            }
          }
        });

        if (powerMode) {
          powerModeTimer--;
          if (powerModeTimer <= 0) {
            powerMode = false;
            ghosts.forEach(ghost => {
              ghost.vulnerable = false;
            });
          }
        }
      }

      function resetPositions() {
        player.x = 15;
        player.y = 15;
        player.direction = 0;
        ghosts[0].x = 14;
        ghosts[0].y = 9;
        ghosts[1].x = 13;
        ghosts[1].y = 9;
        ghosts[2].x = 15;
        ghosts[2].y = 9;
        ghosts[3].x = 14;
        ghosts[3].y = 10;
      }

      function nextLevel() {
        level++;
        dotsEaten = 0;

        for (let row = 0; row < maze.length; row++) {
          for (let col = 0; col < maze[row].length; col++) {
            if (maze[row][col] === 0) {
              if (
                (row === 2 && col === 1) ||
                (row === 2 && col === 28) ||
                (row === 17 && col === 1) ||
                (row === 17 && col === 28)
              ) {
                maze[row][col] = 3;
              } else if (row !== 9 && row !== 10) {
                maze[row][col] = 2;
              }
            }
          }
        }
        resetPositions();
      }

      function gameOver() {
        gameRunning = false;
        playGameOverSound();

        if (currentUser && db && score > 0) {
          console.log('Attempting to submit Dot Muncher score:', score);
          submitScore('dotmuncher', score);
        }

        showGameOverScreen();
      }

      function showGameOverScreen() {
        const gameOverDiv = document.createElement('div');
        gameOverDiv.id = 'gameOverScreen';
        gameOverDiv.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.9);
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          font-family: 'Courier New', monospace;
          color: white;
          z-index: 1000;
        `;

        gameOverDiv.innerHTML = `
          <h1 style="font-size: 4rem; color: #ff0000; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 3px;">GAME OVER</h1>
          <h2 style="font-size: 2rem; color: #00ff00; margin-bottom: 10px;">Final Score: ${score}</h2>
          <h3 style="font-size: 1.5rem; color: #ffff00; margin-bottom: 30px;">Level Reached: ${level}</h3>
          <button id="playAgainBtn" style="
            background: black;
            color: white;
            border: 2px solid white;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
          ">🟡 Play Again</button>
          <button id="backToMenuBtn" style="
            background: black;
            color: white;
            border: 2px solid white;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
          ">🏠 Back to Menu</button>
          <button id="viewLeaderboardBtn" style="
            background: black;
            color: white;
            border: 2px solid #00ff00;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
          ">🏆 View Leaderboard</button>
        `;

        document.body.appendChild(gameOverDiv);

        const playAgainBtn = document.getElementById('playAgainBtn');
        const backToMenuBtn = document.getElementById('backToMenuBtn');
        const viewLeaderboardBtn =
          document.getElementById('viewLeaderboardBtn');

        [playAgainBtn, backToMenuBtn, viewLeaderboardBtn].forEach(btn => {
          btn.addEventListener('mouseenter', () => {
            btn.style.background = 'white';
            btn.style.color = 'black';
          });
          btn.addEventListener('mouseleave', () => {
            btn.style.background = 'black';
            btn.style.color = 'white';
          });
        });

        playAgainBtn.addEventListener('click', () => {
          document.body.removeChild(gameOverDiv);
          restartGame();
        });

        backToMenuBtn.addEventListener('click', () => {
          window.location.href = 'index.html';
        });

        viewLeaderboardBtn.addEventListener('click', () => {
          window.location.href = 'index.html#leaderboard';
        });
      }

      async function submitScore(gameName, finalScore) {
        console.log('=== DOT MUNCHER SCORE SUBMISSION DEBUG ===');
        console.log('submitScore called with:', gameName, finalScore);
        console.log('Current user:', currentUser);
        console.log('Database available:', !!db);
        console.log('Auth state:', auth.currentUser);

        if (!currentUser || !db) {
          console.log(
            '❌ User not logged in or Firebase not available - score not submitted'
          );
          return;
        }

        try {
          console.log('✅ Submitting Dot Muncher score to Firebase...');
          const numericScore =
            typeof finalScore === 'number'
              ? finalScore
              : parseInt(finalScore) || 0;

          const scoreDoc = await db
            .collection('leaderboards')
            .doc(gameName)
            .collection('scores')
            .add({
              userId: currentUser.uid,
              username:
                currentUser.displayName || currentUser.email.split('@')[0],
              score: numericScore,
              level: level,
              timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            });

          console.log('✅ Dot Muncher score document written:', scoreDoc.id);
          const userRef = db.collection('users').doc(currentUser.uid);
          const userDoc = await userRef.get();

          if (userDoc.exists) {
            const userData = userDoc.data();
            const personalBests = userData.personalBests || {};

            if (
              !personalBests[gameName] ||
              numericScore > personalBests[gameName]
            ) {
              personalBests[gameName] = numericScore;
              await userRef.update({ personalBests: personalBests });
              console.log(
                '✅ Dot Muncher personal best updated to:',
                numericScore
              );
            }
          } else {
            await userRef.set({
              personalBests: { [gameName]: numericScore },
            });
            console.log(
              '✅ New user document created with Dot Muncher personal best:',
              numericScore
            );
          }

          console.log(
            '✅ Dot Muncher score submitted successfully:',
            numericScore
          );
        } catch (error) {
          console.error('❌ Error submitting Dot Muncher score:', error);
          console.error('Error code:', error.code);
          console.error('Error message:', error.message);
        }
      }

      function restartGame() {
        score = 0;
        lives = 3;
        level = 1;
        dotsEaten = 0;
        gameRunning = true;
        powerMode = false;
        powerModeTimer = 0;
        nextLevel();
      }

      function drawMaze() {
        ctx.fillStyle = '#0000ff';
        ctx.strokeStyle = '#0000ff';
        ctx.lineWidth = 2;

        for (let row = 0; row < maze.length; row++) {
          for (let col = 0; col < maze[row].length; col++) {
            const x = col * CELL_SIZE;
            const y = row * CELL_SIZE;

            if (maze[row][col] === 1) {
              ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
            } else if (maze[row][col] === 2) {
              ctx.fillStyle = '#ffff00';
              ctx.beginPath();
              ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#0000ff';
            } else if (maze[row][col] === 3) {
              ctx.fillStyle = '#ffff00';
              ctx.beginPath();
              ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, 6, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#0000ff';
            }
          }
        }
      }

      function drawPlayer() {
        const x = player.x * CELL_SIZE + CELL_SIZE / 2;
        const y = player.y * CELL_SIZE + CELL_SIZE / 2;
        const radius = CELL_SIZE / 2 - 2;

        ctx.fillStyle = '#ffff00';
        ctx.beginPath();

        if (player.mouthOpen) {
          const mouthAngle = Math.PI / 3;
          const startAngle = (player.direction * Math.PI) / 2 - mouthAngle / 2;
          const endAngle = (player.direction * Math.PI) / 2 + mouthAngle / 2;

          ctx.arc(x, y, radius, endAngle, startAngle);
          ctx.lineTo(x, y);
        } else {
          ctx.arc(x, y, radius, 0, Math.PI * 2);
        }

        ctx.fill();
      }

      function drawGhosts() {
        ghosts.forEach(ghost => {
          const x = ghost.x * CELL_SIZE + CELL_SIZE / 2;
          const y = ghost.y * CELL_SIZE + CELL_SIZE / 2;
          const radius = CELL_SIZE / 2 - 2;

          if (powerMode && ghost.vulnerable) {
            ctx.fillStyle = '#0000ff';
          } else {
            ctx.fillStyle = ghost.color;
          }

          ctx.beginPath();
          ctx.arc(x, y - radius / 2, radius, Math.PI, 0);
          ctx.rect(x - radius, y - radius / 2, radius * 2, radius * 1.2);
          ctx.fill();
          ctx.fillStyle = 'white';
          ctx.beginPath();
          ctx.arc(x - radius / 3, y - radius / 3, radius / 4, 0, Math.PI * 2);
          ctx.arc(x + radius / 3, y - radius / 3, radius / 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = 'black';
          ctx.beginPath();
          ctx.arc(x - radius / 3, y - radius / 3, radius / 6, 0, Math.PI * 2);
          ctx.arc(x + radius / 3, y - radius / 3, radius / 6, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function updateUI() {
        scoreElement.textContent = score;
        livesElement.textContent = lives;
        levelElement.textContent = level;
      }

      function gameLoop() {
        ctx.fillStyle = '#000033';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        updatePlayer();
        updateGhosts();
        drawMaze();
        drawPlayer();
        drawGhosts();
        updateUI();

        setTimeout(gameLoop, 100);
      }
      gameLoop();
    </script>
  </body>
</html>
