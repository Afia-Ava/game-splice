<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dot Muncher - Game Hub</title>
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        background: #000000;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: 'Courier New', monospace;
        color: white;
        overflow: hidden;
      }

      .back-button {
        position: absolute;
        top: 20px;
        left: 20px;
        background: black;
        color: white;
        border: 2px solid white;
        padding: 10px 20px;
        text-decoration: none;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.3s ease;
        z-index: 1000;
      }

      .back-button:hover {
        background: white;
        color: black;
        border: 2px solid black;
      }

      .game-container {
        display: flex;
        gap: 20px;
        align-items: center;
        justify-content: center;
        margin-top: -20px;
        position: relative;
      }

      #gameCanvas {
        border: 2px solid white;
        background: #000033;
      }

      .game-info {
        position: fixed;
        top: 15px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        z-index: 100;
      }

      .score {
        background: #000000;
        border: 2px solid white;
        padding: 6px 8px;
        text-align: left;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        min-width: 90px;
        font-size: 0.7rem;
        line-height: 1.2;
      }

      .controls {
        background: #000000;
        border: 2px solid white;
        padding: 5px 6px;
        font-family: 'Courier New', monospace;
        font-size: 0.6rem;
        line-height: 1.2;
        text-transform: uppercase;
        letter-spacing: 1px;
        min-width: 90px;
      }

      .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid white;
        padding: 40px;
        text-align: center;
        font-family: 'Courier New', monospace;
        color: white;
        z-index: 1000;
        display: none;
      }

      .game-over h2 {
        font-size: 2rem;
        margin-bottom: 20px;
        color: #ff0000;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .game-over button {
        background: black;
        color: white;
        border: 2px solid white;
        padding: 15px 30px;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: 20px;
      }

      .game-over button:hover {
        background: white;
        color: black;
      }

      @media (max-width: 768px) {
        .game-container {
          flex-direction: column;
          align-items: center;
        }

        #gameCanvas {
          width: 90vw;
          height: auto;
        }

        .game-info {
          position: fixed;
          top: 8px;
          right: 5px;
          gap: 4px;
        }

        .score,
        .controls {
          min-width: 75px;
          font-size: 0.6rem;
          padding: 4px 5px;
        }

        .controls {
          font-size: 0.55rem;
          padding: 3px 4px;
        }
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="back-button">Back</a>

    <div class="game-container">
      <canvas id="gameCanvas" width="600" height="460"></canvas>
      <div class="game-info">
        <div class="score">
          Score: <span id="score">0</span><br />
          Lives: <span id="lives">3</span><br />
          Level: <span id="level">1</span>
        </div>
        <div class="controls">
          Arrow keys to move<br />
          Collect all dots<br />
          Avoid the ghosts!<br />
          Power pellets make ghosts vulnerable
        </div>
      </div>
    </div>

    <div class="game-over" id="gameOver">
      <h2>Game Over!</h2>
      <p>Final Score: <span id="finalScore">0</span></p>
      <button onclick="restartGame()">Play Again</button>
    </div>

    <script>
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreElement = document.getElementById('score');
      const livesElement = document.getElementById('lives');
      const levelElement = document.getElementById('level');
      const gameOverElement = document.getElementById('gameOver');
      const finalScoreElement = document.getElementById('finalScore');
      const CELL_SIZE = 20;
      const COLS = canvas.width / CELL_SIZE;
      const ROWS = 23;

      let score = 0;
      let lives = 3;
      let level = 1;
      let gameRunning = true;
      let powerMode = false;
      let powerModeTimer = 0;
      const maze = [
        [
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1,
          2, 1, 1, 1, 1, 3, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,
          2, 1, 1, 1, 1, 2, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
          2, 1, 1, 1, 1, 1, 1,
        ],
        [
          0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
          2, 1, 0, 0, 0, 0, 0,
        ],
        [
          0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1,
          2, 1, 0, 0, 0, 0, 0,
        ],
        [
          1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
          2, 1, 1, 1, 1, 1, 1,
        ],
        [
          0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
          2, 0, 0, 0, 0, 0, 0,
        ],
        [
          1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1,
          2, 1, 1, 1, 1, 1, 1,
        ],
        [
          0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1,
          2, 1, 0, 0, 0, 0, 0,
        ],
        [
          0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
          2, 1, 0, 0, 0, 0, 0,
        ],
        [
          1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
          2, 1, 1, 1, 1, 1, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1,
          2, 1, 1, 1, 1, 2, 1,
        ],
        [
          1, 3, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 1, 1, 2, 2, 3, 1,
        ],
        [
          1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1,
          2, 1, 1, 2, 1, 1, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 2, 1,
        ],
        [
          1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 1,
        ],
        [
          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
          1, 1, 1, 1, 1, 1, 1,
        ],
      ];

      const player = {
        x: 15,
        y: 15,
        direction: 0,
        nextDirection: 0,
        mouthOpen: true,
      };

      const ghosts = [
        { x: 14, y: 9, direction: 0, color: '#ff0000', vulnerable: false },
        { x: 13, y: 9, direction: 1, color: '#ffb8ff', vulnerable: false },
        { x: 15, y: 9, direction: 2, color: '#00ffff', vulnerable: false },
        { x: 14, y: 10, direction: 3, color: '#ffb852', vulnerable: false },
      ];

      const directions = [
        { x: 1, y: 0 },
        { x: 0, y: 1 },
        { x: -1, y: 0 },
        { x: 0, y: -1 },
      ];

      let totalDots = 0;
      let dotsEaten = 0;
      for (let row = 0; row < maze.length; row++) {
        for (let col = 0; col < maze[row].length; col++) {
          if (maze[row][col] === 2 || maze[row][col] === 3) {
            totalDots++;
          }
        }
      }

      const keys = {};
      document.addEventListener('keydown', e => {
        keys[e.key] = true;

        switch (e.key) {
          case 'ArrowRight':
            player.nextDirection = 0;
            break;
          case 'ArrowDown':
            player.nextDirection = 1;
            break;
          case 'ArrowLeft':
            player.nextDirection = 2;
            break;
          case 'ArrowUp':
            player.nextDirection = 3;
            break;
        }
        e.preventDefault();
      });

      document.addEventListener('keyup', e => {
        keys[e.key] = false;
      });

      function canMove(x, y) {
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
        return maze[y][x] !== 1;
      }

      function updatePlayer() {
        if (!gameRunning) return;
        const nextDir = directions[player.nextDirection];
        const nextX = player.x + nextDir.x;
        const nextY = player.y + nextDir.y;

        if (canMove(nextX, nextY)) {
          player.direction = player.nextDirection;
        }

        const dir = directions[player.direction];
        const newX = player.x + dir.x;
        const newY = player.y + dir.y;

        if (canMove(newX, newY)) {
          player.x = newX;
          player.y = newY;

          if (player.x < 0) player.x = COLS - 1;
          if (player.x >= COLS) player.x = 0;
          if (maze[player.y][player.x] === 2) {
            maze[player.y][player.x] = 0;
            score += 10;
            dotsEaten++;
          } else if (maze[player.y][player.x] === 3) {
            maze[player.y][player.x] = 0;
            score += 50;
            dotsEaten++;
            activatePowerMode();
          }
          if (dotsEaten >= totalDots) {
            nextLevel();
          }
        }
        player.mouthOpen = !player.mouthOpen;
      }

      function activatePowerMode() {
        powerMode = true;
        powerModeTimer = 300;
        ghosts.forEach(ghost => {
          ghost.vulnerable = true;
        });
      }

      function updateGhosts() {
        if (!gameRunning) return;

        ghosts.forEach(ghost => {
          if (Math.random() < 0.05) {
            ghost.direction = Math.floor(Math.random() * 4);
          }

          const dir = directions[ghost.direction];
          const newX = ghost.x + dir.x;
          const newY = ghost.y + dir.y;

          if (canMove(newX, newY)) {
            ghost.x = newX;
            ghost.y = newY;

            if (ghost.x < 0) ghost.x = COLS - 1;
            if (ghost.x >= COLS) ghost.x = 0;
          } else {
            ghost.direction = Math.floor(Math.random() * 4);
          }

          if (ghost.x === player.x && ghost.y === player.y) {
            if (powerMode && ghost.vulnerable) {
              score += 200;
              ghost.x = 14;
              ghost.y = 9;
              ghost.vulnerable = false;
            } else {
              lives--;
              resetPositions();
              if (lives <= 0) {
                gameOver();
              }
            }
          }
        });

        if (powerMode) {
          powerModeTimer--;
          if (powerModeTimer <= 0) {
            powerMode = false;
            ghosts.forEach(ghost => {
              ghost.vulnerable = false;
            });
          }
        }
      }

      function resetPositions() {
        player.x = 15;
        player.y = 15;
        player.direction = 0;
        ghosts[0].x = 14;
        ghosts[0].y = 9;
        ghosts[1].x = 13;
        ghosts[1].y = 9;
        ghosts[2].x = 15;
        ghosts[2].y = 9;
        ghosts[3].x = 14;
        ghosts[3].y = 10;
      }

      function nextLevel() {
        level++;
        dotsEaten = 0;

        for (let row = 0; row < maze.length; row++) {
          for (let col = 0; col < maze[row].length; col++) {
            if (maze[row][col] === 0) {
              if (
                (row === 2 && col === 1) ||
                (row === 2 && col === 28) ||
                (row === 17 && col === 1) ||
                (row === 17 && col === 28)
              ) {
                maze[row][col] = 3;
              } else if (row !== 9 && row !== 10) {
                maze[row][col] = 2;
              }
            }
          }
        }
        resetPositions();
      }

      function gameOver() {
        gameRunning = false;
        finalScoreElement.textContent = score;
        gameOverElement.style.display = 'block';
      }

      function restartGame() {
        score = 0;
        lives = 3;
        level = 1;
        dotsEaten = 0;
        gameRunning = true;
        powerMode = false;
        powerModeTimer = 0;
        nextLevel();
        gameOverElement.style.display = 'none';
      }

      function drawMaze() {
        ctx.fillStyle = '#0000ff';
        ctx.strokeStyle = '#0000ff';
        ctx.lineWidth = 2;

        for (let row = 0; row < maze.length; row++) {
          for (let col = 0; col < maze[row].length; col++) {
            const x = col * CELL_SIZE;
            const y = row * CELL_SIZE;

            if (maze[row][col] === 1) {
              ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
            } else if (maze[row][col] === 2) {
              ctx.fillStyle = '#ffff00';
              ctx.beginPath();
              ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#0000ff';
            } else if (maze[row][col] === 3) {
              ctx.fillStyle = '#ffff00';
              ctx.beginPath();
              ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, 6, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#0000ff';
            }
          }
        }
      }

      function drawPlayer() {
        const x = player.x * CELL_SIZE + CELL_SIZE / 2;
        const y = player.y * CELL_SIZE + CELL_SIZE / 2;
        const radius = CELL_SIZE / 2 - 2;

        ctx.fillStyle = '#ffff00';
        ctx.beginPath();

        if (player.mouthOpen) {
          const mouthAngle = Math.PI / 3;
          const startAngle = (player.direction * Math.PI) / 2 - mouthAngle / 2;
          const endAngle = (player.direction * Math.PI) / 2 + mouthAngle / 2;

          ctx.arc(x, y, radius, endAngle, startAngle);
          ctx.lineTo(x, y);
        } else {
          ctx.arc(x, y, radius, 0, Math.PI * 2);
        }

        ctx.fill();
      }

      function drawGhosts() {
        ghosts.forEach(ghost => {
          const x = ghost.x * CELL_SIZE + CELL_SIZE / 2;
          const y = ghost.y * CELL_SIZE + CELL_SIZE / 2;
          const radius = CELL_SIZE / 2 - 2;

          if (powerMode && ghost.vulnerable) {
            ctx.fillStyle = '#0000ff';
          } else {
            ctx.fillStyle = ghost.color;
          }

          ctx.beginPath();
          ctx.arc(x, y - radius / 2, radius, Math.PI, 0);
          ctx.rect(x - radius, y - radius / 2, radius * 2, radius * 1.2);
          ctx.fill();
          ctx.fillStyle = 'white';
          ctx.beginPath();
          ctx.arc(x - radius / 3, y - radius / 3, radius / 4, 0, Math.PI * 2);
          ctx.arc(x + radius / 3, y - radius / 3, radius / 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = 'black';
          ctx.beginPath();
          ctx.arc(x - radius / 3, y - radius / 3, radius / 6, 0, Math.PI * 2);
          ctx.arc(x + radius / 3, y - radius / 3, radius / 6, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function updateUI() {
        scoreElement.textContent = score;
        livesElement.textContent = lives;
        levelElement.textContent = level;
      }

      function gameLoop() {
        ctx.fillStyle = '#000033';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        updatePlayer();
        updateGhosts();
        drawMaze();
        drawPlayer();
        drawGhosts();
        updateUI();

        setTimeout(gameLoop, 100);
      }
      gameLoop();
    </script>
  </body>
</html>
