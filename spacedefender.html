<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Space Defender - Defend Earth</title>
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />

    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <script src="firebase-config.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        background: #000000;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: 'Courier New', monospace;
        color: white;
        overflow: hidden;
      }

      .back-button {
        position: absolute;
        top: 20px;
        left: 20px;
        background: black;
        color: white;
        border: 2px solid white;
        padding: 10px 20px;
        text-decoration: none;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.3s ease;
        z-index: 1000;
      }

      .back-button:hover {
        background: white;
        color: black;
        border: 2px solid black;
      }

      .game-container {
        display: flex;
        gap: 20px;
        align-items: center;
        justify-content: center;
        margin-top: -20px;
        position: relative;
      }

      #gameCanvas {
        border: 2px solid white;
        background: #000011;
      }

      .game-info {
        position: fixed;
        top: 15px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        z-index: 100;
      }

      .score {
        background: #000000;
        border: 2px solid white;
        padding: 6px 8px;
        text-align: left;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        min-width: 90px;
        font-size: 0.7rem;
        line-height: 1.2;
      }

      .controls {
        background: #000000;
        border: 2px solid white;
        padding: 5px 6px;
        font-family: 'Courier New', monospace;
        font-size: 0.6rem;
        line-height: 1.2;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        max-width: 140px;
      }

      .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid white;
        padding: 30px;
        text-align: center;
        font-family: 'Courier New', monospace;
        z-index: 200;
        display: none;
      }

      .game-over h2 {
        color: #ff4444;
        font-size: 2rem;
        margin-bottom: 20px;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .restart-btn {
        background: black;
        color: white;
        border: 2px solid white;
        padding: 15px 30px;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: 20px;
      }

      .restart-btn:hover {
        background: white;
        color: black;
        border: 2px solid black;
      }

      @media (max-width: 768px) {
        .game-info {
          position: fixed;
          top: 10px;
          right: 5px;
          gap: 4px;
        }

        .score,
        .controls {
          font-size: 0.6rem;
          padding: 4px 6px;
          min-width: 80px;
          max-width: 120px;
        }

        #gameCanvas {
          width: 95vw;
          height: 70vh;
        }
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="back-button">Back</a>

    <div class="game-container">
      <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div class="game-info">
      <div class="score">
        Score: <span id="scoreValue">0</span><br />
        Lives: <span id="livesValue">3</span><br />
        Level: <span id="levelValue">1</span>
      </div>
      <div class="controls">
        WASD/Arrows: Move<br />
        Space: Shoot<br />
        R: Restart
      </div>
    </div>

    <div class="game-over" id="gameOverScreen">
      <h2>Game Over</h2>
      <p>Final Score: <span id="finalScore">0</span></p>
      <p>Level Reached: <span id="finalLevel">1</span></p>
      <button class="restart-btn" onclick="restartGame()">Play Again</button>
    </div>

    <script>
      if (typeof window.firebaseConfig === 'undefined') {
        console.error(
          'Firebase configuration not loaded. Please check firebase-config.js'
        );
      }

      let auth,
        db,
        currentUser = null;
      try {
        firebase.initializeApp(window.firebaseConfig);
        auth = firebase.auth();
        db = firebase.firestore();
        console.log('Firebase initialized successfully in Space Defender');
      } catch (error) {
        console.error(
          'Firebase initialization error in Space Defender:',
          error
        );
      }

      auth.onAuthStateChanged(user => {
        currentUser = user;
      });

      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      let audioContext;
      let masterGain;
      let backgroundMusic;
      let musicGain;
      function initAudio() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          masterGain = audioContext.createGain();
          masterGain.gain.value = 0.3;
          masterGain.connect(audioContext.destination);
          startBackgroundMusic();
        } catch (e) {
          console.log('Web Audio API not supported');
        }
      }

      function startBackgroundMusic() {
        if (!audioContext) return;
        musicGain = audioContext.createGain();
        musicGain.gain.value = 0.15;
        musicGain.connect(masterGain);
      }

      function playBackgroundMusic() {
        if (!audioContext) return;
        const drone1 = audioContext.createOscillator();
        const drone2 = audioContext.createOscillator();
        const drone3 = audioContext.createOscillator();
        const filter1 = audioContext.createBiquadFilter();
        const filter2 = audioContext.createBiquadFilter();
        const filter3 = audioContext.createBiquadFilter();
        const gain1 = audioContext.createGain();
        const gain2 = audioContext.createGain();
        const gain3 = audioContext.createGain();
        drone1.type = 'sine';
        drone1.frequency.setValueAtTime(55, audioContext.currentTime);
        drone2.type = 'sine';
        drone2.frequency.setValueAtTime(82.4, audioContext.currentTime);
        drone3.type = 'triangle';
        drone3.frequency.setValueAtTime(110, audioContext.currentTime);
        const lfo1 = audioContext.createOscillator();
        const lfo2 = audioContext.createOscillator();
        const lfoGain1 = audioContext.createGain();
        const lfoGain2 = audioContext.createGain();

        lfo1.type = 'sine';
        lfo1.frequency.setValueAtTime(0.1, audioContext.currentTime);
        lfoGain1.gain.setValueAtTime(2, audioContext.currentTime);
        lfo2.type = 'sine';
        lfo2.frequency.setValueAtTime(0.07, audioContext.currentTime);
        lfoGain2.gain.setValueAtTime(1, audioContext.currentTime);
        lfo1.connect(lfoGain1);
        lfoGain1.connect(drone1.frequency);
        lfo2.connect(lfoGain2);
        lfoGain2.connect(drone3.frequency);
        filter1.type = 'lowpass';
        filter1.frequency.setValueAtTime(800, audioContext.currentTime);
        filter1.Q.setValueAtTime(1, audioContext.currentTime);

        filter2.type = 'lowpass';
        filter2.frequency.setValueAtTime(600, audioContext.currentTime);
        filter2.Q.setValueAtTime(1, audioContext.currentTime);
        filter3.type = 'lowpass';
        filter3.frequency.setValueAtTime(1000, audioContext.currentTime);
        filter3.Q.setValueAtTime(0.5, audioContext.currentTime);
        gain1.gain.setValueAtTime(0.3, audioContext.currentTime);
        gain2.gain.setValueAtTime(0.2, audioContext.currentTime);
        gain3.gain.setValueAtTime(0.1, audioContext.currentTime);

        drone1.connect(filter1);
        filter1.connect(gain1);
        gain1.connect(musicGain);
        drone2.connect(filter2);
        filter2.connect(gain2);
        gain2.connect(musicGain);
        drone3.connect(filter3);
        filter3.connect(gain3);
        gain3.connect(musicGain);
        const now = audioContext.currentTime;
        drone1.start(now);
        drone2.start(now);
        drone3.start(now);
        lfo1.start(now);
        lfo2.start(now);

        setTimeout(() => {
          playSpaceArpeggio();
        }, 2000);

        setTimeout(() => {
          if (gameRunning && audioContext) {
            playBackgroundMusic();
          }
        }, 15000);
      }

      function playSpaceArpeggio() {
        if (!audioContext || !gameRunning) return;

        const notes = [220, 246.94, 293.66, 369.99];
        const startTime = audioContext.currentTime;

        notes.forEach((freq, index) => {
          const osc = audioContext.createOscillator();
          const gain = audioContext.createGain();
          const filter = audioContext.createBiquadFilter();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, startTime + index * 0.5);
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(1500, startTime + index * 0.5);
          gain.gain.setValueAtTime(0, startTime + index * 0.5);
          gain.gain.linearRampToValueAtTime(
            0.08,
            startTime + index * 0.5 + 0.1
          );
          gain.gain.exponentialRampToValueAtTime(
            0.001,
            startTime + index * 0.5 + 1.5
          );

          osc.connect(filter);
          filter.connect(gain);
          gain.connect(musicGain);
          osc.start(startTime + index * 0.5);
          osc.stop(startTime + index * 0.5 + 1.5);
        });

        setTimeout(() => {
          if (gameRunning && audioContext) {
            playSpaceArpeggio();
          }
        }, 8000);
      }

      function stopBackgroundMusic() {
        if (musicGain) {
          musicGain.gain.exponentialRampToValueAtTime(
            0.001,
            audioContext.currentTime + 1
          );
        }
      }

      function playShootSound() {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(masterGain);
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          200,
          audioContext.currentTime + 0.1
        );

        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.1
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
      }

      function playExplosionSound() {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(masterGain);
        oscillator.type = 'sawtooth';
        oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          50,
          audioContext.currentTime + 0.3
        );

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(2000, audioContext.currentTime);
        filter.frequency.exponentialRampToValueAtTime(
          200,
          audioContext.currentTime + 0.3
        );

        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.3
        );

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      }

      function playPowerUpSound() {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(masterGain);
        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(
          600,
          audioContext.currentTime + 0.1
        );
        oscillator.frequency.setValueAtTime(
          800,
          audioContext.currentTime + 0.2
        );
        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + 0.2);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.3
        );
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      }

      function playGameOverSound() {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(masterGain);
        oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          100,
          audioContext.currentTime + 1
        );
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 1
        );
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 1);
      }

      function playLevelUpSound() {
        if (!audioContext) return;

        const notes = [440, 554, 659, 880];
        notes.forEach((freq, index) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(masterGain);

          oscillator.frequency.setValueAtTime(
            freq,
            audioContext.currentTime + index * 0.1
          );

          gainNode.gain.setValueAtTime(
            0.2,
            audioContext.currentTime + index * 0.1
          );
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + index * 0.1 + 0.2
          );

          oscillator.start(audioContext.currentTime + index * 0.1);
          oscillator.stop(audioContext.currentTime + index * 0.1 + 0.2);
        });
      }

      let audioInitialized = false;
      document.addEventListener('click', () => {
        if (!audioInitialized) {
          initAudio();
          playBackgroundMusic();
          audioInitialized = true;
        }
      });

      document.addEventListener('keydown', () => {
        if (!audioInitialized) {
          initAudio();
          playBackgroundMusic();
          audioInitialized = true;
        }
      });

      let score = 0;
      let lives = 3;
      let level = 1;
      let gameRunning = true;
      let keys = {};

      const player = {
        x: canvas.width / 2 - 25,
        y: canvas.height - 80,
        width: 50,
        height: 40,
        speed: 5,
      };

      let bullets = [];
      let enemies = [];
      let powerUps = [];
      let explosions = [];
      let stars = [];
      let enemySpawnTimer = 0;
      let powerUpSpawnTimer = 0;
      let bulletCooldown = 0;

      for (let i = 0; i < 100; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 2 + 1,
          speed: Math.random() * 2 + 1,
        });
      }

      document.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;

        if (e.key === ' ' || e.key === 'Spacebar') {
          e.preventDefault();
          if (bulletCooldown <= 0) {
            shootBullet();
            bulletCooldown = 10;
          }
        }

        if (e.key.toLowerCase() === 'r') {
          restartGame();
        }
      });

      document.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
      });

      function shootBullet() {
        playShootSound();
        bullets.push({
          x: player.x + player.width / 2 - 2,
          y: player.y,
          width: 4,
          height: 15,
          speed: 8,
          color: '#00ff00',
        });
      }

      function spawnEnemy() {
        const enemyTypes = [
          { width: 30, height: 25, speed: 2, points: 100, color: '#ff4444' },
          { width: 40, height: 30, speed: 1.5, points: 150, color: '#ff8844' },
          { width: 25, height: 20, speed: 3, points: 75, color: '#ff44ff' },
        ];

        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

        enemies.push({
          x: Math.random() * (canvas.width - type.width),
          y: -type.height,
          width: type.width,
          height: type.height,
          speed: type.speed + level * 0.5,
          points: type.points,
          color: type.color,
          shootTimer: Math.random() * 120 + 60,
        });
      }

      function spawnPowerUp() {
        const powerUpTypes = [
          { type: 'rapidFire', color: '#00ff00', duration: 300 },
          { type: 'shield', color: '#0088ff', duration: 200 },
          { type: 'multiShot', color: '#ffff00', duration: 250 },
        ];

        const type =
          powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];

        powerUps.push({
          x: Math.random() * (canvas.width - 20),
          y: -20,
          width: 20,
          height: 20,
          speed: 2,
          type: type.type,
          color: type.color,
          duration: type.duration,
        });
      }

      function createExplosion(x, y, size = 30) {
        explosions.push({
          x: x,
          y: y,
          size: size,
          maxSize: size,
          life: 20,
          maxLife: 20,
        });
      }

      function updatePlayer() {
        if (keys['a'] || keys['arrowleft']) {
          player.x = Math.max(0, player.x - player.speed);
        }
        if (keys['d'] || keys['arrowright']) {
          player.x = Math.min(
            canvas.width - player.width,
            player.x + player.speed
          );
        }
        if (keys['w'] || keys['arrowup']) {
          player.y = Math.max(0, player.y - player.speed);
        }
        if (keys['s'] || keys['arrowdown']) {
          player.y = Math.min(
            canvas.height - player.height,
            player.y + player.speed
          );
        }
      }

      function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.y -= bullet.speed;

          if (bullet.y < 0) {
            bullets.splice(i, 1);
            continue;
          }

          for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            if (
              bullet.x < enemy.x + enemy.width &&
              bullet.x + bullet.width > enemy.x &&
              bullet.y < enemy.y + enemy.height &&
              bullet.y + bullet.height > enemy.y
            ) {
              createExplosion(
                enemy.x + enemy.width / 2,
                enemy.y + enemy.height / 2
              );
              playExplosionSound();
              score += enemy.points;
              bullets.splice(i, 1);
              enemies.splice(j, 1);
              break;
            }
          }
        }
      }

      function updateEnemies() {
        for (let i = enemies.length - 1; i >= 0; i--) {
          const enemy = enemies[i];
          enemy.y += enemy.speed;

          if (enemy.y > canvas.height) {
            enemies.splice(i, 1);
            continue;
          }

          if (
            enemy.x < player.x + player.width &&
            enemy.x + enemy.width > player.x &&
            enemy.y < player.y + player.height &&
            enemy.y + enemy.height > player.y
          ) {
            createExplosion(
              player.x + player.width / 2,
              player.y + player.height / 2,
              50
            );
            playExplosionSound();
            lives--;
            enemies.splice(i, 1);

            if (lives <= 0) {
              gameOver();
            }
          }
        }
      }

      function updatePowerUps() {
        for (let i = powerUps.length - 1; i >= 0; i--) {
          const powerUp = powerUps[i];
          powerUp.y += powerUp.speed;

          if (powerUp.y > canvas.height) {
            powerUps.splice(i, 1);
            continue;
          }

          if (
            powerUp.x < player.x + player.width &&
            powerUp.x + powerUp.width > player.x &&
            powerUp.y < player.y + player.height &&
            powerUp.y + powerUp.height > player.y
          ) {
            playPowerUpSound();
            score += 50;
            powerUps.splice(i, 1);
          }
        }
      }

      function updateExplosions() {
        for (let i = explosions.length - 1; i >= 0; i--) {
          const explosion = explosions[i];
          explosion.life--;

          if (explosion.life <= 0) {
            explosions.splice(i, 1);
          }
        }
      }

      function updateStars() {
        for (let star of stars) {
          star.y += star.speed;
          if (star.y > canvas.height) {
            star.y = 0;
            star.x = Math.random() * canvas.width;
          }
        }
      }

      function drawPlayer() {
        ctx.fillStyle = '#00aaff';
        ctx.fillRect(player.x, player.y, player.width, player.height);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(player.x + player.width / 2 - 2, player.y - 5, 4, 10);
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(player.x + 5, player.y + player.height - 10, 8, 8);
        ctx.fillRect(
          player.x + player.width - 13,
          player.y + player.height - 10,
          8,
          8
        );
      }

      function drawBullets() {
        for (let bullet of bullets) {
          ctx.fillStyle = bullet.color;
          ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        }
      }

      function drawEnemies() {
        for (let enemy of enemies) {
          ctx.fillStyle = enemy.color;
          ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(enemy.x + 5, enemy.y + 5, 4, 4);
          ctx.fillRect(enemy.x + enemy.width - 9, enemy.y + 5, 4, 4);
        }
      }

      function drawPowerUps() {
        for (let powerUp of powerUps) {
          ctx.fillStyle = powerUp.color;
          ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
          ctx.strokeStyle = '#ffffff';
          ctx.strokeRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
        }
      }

      function drawExplosions() {
        for (let explosion of explosions) {
          const alpha = explosion.life / explosion.maxLife;
          const size = explosion.size * (1 - alpha * 0.5);
          ctx.globalAlpha = alpha;
          ctx.fillStyle = '#ffaa00';
          ctx.beginPath();
          ctx.arc(explosion.x, explosion.y, size, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#ff4400';
          ctx.beginPath();
          ctx.arc(explosion.x, explosion.y, size * 0.6, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function drawStars() {
        ctx.fillStyle = '#ffffff';
        for (let star of stars) {
          ctx.globalAlpha = 0.8;
          ctx.fillRect(star.x, star.y, star.size, star.size);
        }
        ctx.globalAlpha = 1;
      }

      function drawUI() {
        document.getElementById('scoreValue').textContent = score;
        document.getElementById('livesValue').textContent = lives;
        document.getElementById('levelValue').textContent = level;
      }

      function gameOver() {
        gameRunning = false;
        stopBackgroundMusic();
        playGameOverSound();

        if (currentUser && db && score > 0) {
          console.log('üéÆ === SPACE DEFENDER GAME OVER ===');
          console.log('üéÆ Final Score:', score);
          console.log('üéÆ Final Level:', level);
          console.log('üéÆ User logged in:', !!currentUser);
          console.log('üéÆ Database available:', !!db);
          console.log('üéÆ User email:', currentUser?.email);
          console.log('üéÆ User displayName:', currentUser?.displayName);
          console.log('üéÆ Attempting to submit Space Defender score:', score);
          submitScore('spacedefender', score);
        } else {
          console.log('üéÆ === SPACE DEFENDER GAME OVER (NO SUBMISSION) ===');
          console.log('üéÆ Score:', score);
          console.log('üéÆ User logged in:', !!currentUser);
          console.log('üéÆ Database available:', !!db);
          console.log('üéÆ Score > 0:', score > 0);
        }

        showGameOverScreen();
      }

      function restartGame() {
        score = 0;
        lives = 3;
        level = 1;
        gameRunning = true;
        player.x = canvas.width / 2 - 25;
        player.y = canvas.height - 80;
        bullets = [];
        enemies = [];
        powerUps = [];
        explosions = [];
        enemySpawnTimer = 0;
        powerUpSpawnTimer = 0;
        bulletCooldown = 0;

        const existingGameOver = document.getElementById('gameOverScreen');
        if (existingGameOver) {
          existingGameOver.remove();
        }

        if (audioContext) {
          startBackgroundMusic();
          playBackgroundMusic();
        }
      }

      function gameLoop() {
        if (!gameRunning) {
          requestAnimationFrame(gameLoop);
          return;
        }
        updatePlayer();
        updateBullets();
        updateEnemies();
        updatePowerUps();
        updateExplosions();
        updateStars();

        enemySpawnTimer++;
        if (enemySpawnTimer > 60 - level * 5) {
          spawnEnemy();
          enemySpawnTimer = 0;
        }

        powerUpSpawnTimer++;
        if (powerUpSpawnTimer > 600) {
          spawnPowerUp();
          powerUpSpawnTimer = 0;
        }

        if (score > level * 1000) {
          level++;
          playLevelUpSound();
        }

        if (bulletCooldown > 0) bulletCooldown--;
        ctx.fillStyle = '#000011';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawStars();
        drawPlayer();
        drawBullets();
        drawEnemies();
        drawPowerUps();
        drawExplosions();
        drawUI();
        requestAnimationFrame(gameLoop);
      }

      function showGameOverScreen() {
        const existingGameOver = document.getElementById('gameOverScreen');
        if (existingGameOver) {
          existingGameOver.remove();
        }

        const gameOverDiv = document.createElement('div');
        gameOverDiv.id = 'gameOverScreen';
        gameOverDiv.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.9);
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          font-family: 'Courier New', monospace;
          color: white;
          z-index: 1000;
        `;

        gameOverDiv.innerHTML = `
          <h1 style="font-size: 4rem; color: #ff0000; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 3px;">GAME OVER</h1>
          <h2 style="font-size: 2rem; color: #00ff00; margin-bottom: 10px;">Final Score: ${score}</h2>
          <h3 style="font-size: 1.5rem; color: #ffff00; margin-bottom: 30px;">Level Reached: ${level}</h3>
          <button id="playAgainBtn" style="
            background: black;
            color: white;
            border: 2px solid white;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
          ">üöÄ Play Again</button>
          <button id="backToMenuBtn" style="
            background: black;
            color: white;
            border: 2px solid white;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
          ">üè† Back to Menu</button>
          <button id="viewLeaderboardBtn" style="
            background: black;
            color: white;
            border: 2px solid #00ff00;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
          ">üèÜ View Leaderboard</button>
        `;

        document.body.appendChild(gameOverDiv);
        const playAgainBtn = document.getElementById('playAgainBtn');
        const backToMenuBtn = document.getElementById('backToMenuBtn');
        const viewLeaderboardBtn =
          document.getElementById('viewLeaderboardBtn');

        [playAgainBtn, backToMenuBtn, viewLeaderboardBtn].forEach(btn => {
          btn.addEventListener('mouseenter', () => {
            btn.style.background = 'white';
            btn.style.color = 'black';
          });
          btn.addEventListener('mouseleave', () => {
            btn.style.background = 'black';
            btn.style.color = 'white';
          });
        });

        playAgainBtn.addEventListener('click', () => {
          document.body.removeChild(gameOverDiv);
          restartGame();
        });

        backToMenuBtn.addEventListener('click', () => {
          window.location.href = 'index.html';
        });

        viewLeaderboardBtn.addEventListener('click', () => {
          window.location.href = 'index.html#leaderboard';
        });
      }

      async function submitScore(gameName, finalScore) {
        console.log('=== SPACE DEFENDER SCORE SUBMISSION DEBUG ===');
        console.log('submitScore called with:', gameName, finalScore);
        console.log('Current user:', currentUser);
        console.log('Database available:', !!db);
        console.log('Auth state:', auth.currentUser);

        if (!currentUser || !db) {
          console.log(
            '‚ùå User not logged in or Firebase not available - score not submitted'
          );
          return;
        }

        try {
          console.log('‚úÖ Submitting Space Defender score to Firebase...');
          const numericScore =
            typeof finalScore === 'number'
              ? finalScore
              : parseInt(finalScore) || 0;

          const scoreDoc = await db
            .collection('leaderboards')
            .doc(gameName)
            .collection('scores')
            .add({
              userId: currentUser.uid,
              username:
                currentUser.displayName || currentUser.email.split('@')[0],
              score: numericScore,
              level: level,
              timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            });

          console.log('‚úÖ Space Defender score document written:', scoreDoc.id);

          const userRef = db.collection('users').doc(currentUser.uid);
          const userDoc = await userRef.get();
          if (userDoc.exists) {
            const userData = userDoc.data();
            const personalBests = userData.personalBests || {};

            if (
              !personalBests[gameName] ||
              numericScore > personalBests[gameName]
            ) {
              await userRef.update({
                [`personalBests.${gameName}`]: numericScore,
              });
              console.log(
                '‚úÖ Updated personal best for Space Defender:',
                numericScore
              );
            }
          } else {
            await userRef.set({
              email: currentUser.email,
              username:
                currentUser.displayName || currentUser.email.split('@')[0],
              personalBests: {
                [gameName]: numericScore,
              },
            });
            console.log(
              '‚úÖ Created user document with Space Defender score:',
              numericScore
            );
          }

          console.log(
            '‚úÖ Space Defender score submission completed successfully'
          );
        } catch (error) {
          console.error('‚ùå Error submitting Space Defender score:', error);
          console.error('Error code:', error.code);
          console.error('Error message:', error.message);
        }
      }

      gameLoop();
    </script>
  </body>
</html>
