<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sky Navigator - Fly Through Obstacles</title>
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
        background: #000000;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: 'Courier New', monospace;
        color: white;
        overflow: hidden;
      }

      .back-button {
        position: absolute;
        top: 20px;
        left: 20px;
        background: black;
        color: white;
        border: 2px solid white;
        padding: 10px 20px;
        text-decoration: none;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.3s ease;
        z-index: 1000;
      }

      .back-button:hover {
        background: white;
        color: black;
        border: 2px solid black;
      }

      .game-container {
        display: flex;
        gap: 20px;
        align-items: center;
        justify-content: center;
        margin-top: -20px;
        position: relative;
      }

      #gameCanvas {
        border: 2px solid white;
        background: #87ceeb;
        cursor: pointer;
      }

      .game-info {
        position: fixed;
        top: 15px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 6px;
        z-index: 100;
      }

      .score {
        background: #000000;
        border: 2px solid white;
        padding: 6px 8px;
        text-align: left;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        min-width: 90px;
        font-size: 0.7rem;
        line-height: 1.2;
      }

      .controls {
        background: #000000;
        border: 2px solid white;
        padding: 5px 6px;
        font-family: 'Courier New', monospace;
        font-size: 0.6rem;
        line-height: 1.2;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        max-width: 140px;
      }

      .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        border: 2px solid white;
        padding: 30px;
        text-align: center;
        font-family: 'Courier New', monospace;
        z-index: 200;
        display: none;
      }

      .game-over h2 {
        color: #ff4444;
        font-size: 2rem;
        margin-bottom: 20px;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .restart-btn {
        background: black;
        color: white;
        border: 2px solid white;
        padding: 15px 30px;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: 20px;
      }

      .restart-btn:hover {
        background: white;
        color: black;
        border: 2px solid black;
      }

      .start-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid white;
        padding: 40px;
        text-align: center;
        font-family: 'Courier New', monospace;
        z-index: 300;
      }

      .start-screen h1 {
        color: #00ff00;
        font-size: 3rem;
        margin-bottom: 20px;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .start-screen p {
        font-size: 1.2rem;
        margin-bottom: 30px;
        color: #ffffff;
      }

      @media (max-width: 768px) {
        .game-info {
          position: fixed;
          top: 10px;
          right: 5px;
          gap: 4px;
        }

        .score,
        .controls {
          font-size: 0.6rem;
          padding: 4px 6px;
          min-width: 80px;
          max-width: 120px;
        }

        #gameCanvas {
          width: 95vw;
          height: 70vh;
        }
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="back-button">Back</a>

    <div class="game-container">
      <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <div class="game-info">
      <div class="score">
        Score: <span id="scoreValue">0</span><br />
        Best: <span id="bestValue">0</span><br />
        Height: <span id="heightValue">0</span>m
      </div>
      <div class="controls">
        Click/Tap: Flap<br />
        Space: Flap<br />
        R: Restart
      </div>
    </div>

    <div class="start-screen" id="startScreen">
      <h1>üê¶ Sky Navigator</h1>
      <p>Click or tap to flap your wings and fly!</p>
      <p>Avoid the obstacles and fly as far as you can!</p>
      <button class="restart-btn" onclick="startGame()">Start Flying</button>
    </div>

    <div class="game-over" id="gameOverScreen">
      <h2>Game Over</h2>
      <p>Final Score: <span id="finalScore">0</span></p>
      <p>Distance: <span id="finalDistance">0</span>m</p>
      <p id="newRecord" style="color: #00ff00; display: none">
        New Best Score!
      </p>
      <button class="restart-btn" onclick="restartGame()">Fly Again</button>
    </div>

    <script>
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      let audioContext;
      let masterGain;

      function initAudio() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          masterGain = audioContext.createGain();
          masterGain.gain.value = 0.25;
          masterGain.connect(audioContext.destination);
        }
      }

      function playFlapSound() {
        initAudio();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          500,
          audioContext.currentTime + 0.05
        );
        oscillator.frequency.exponentialRampToValueAtTime(
          350,
          audioContext.currentTime + 0.1
        );

        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.1
        );

        oscillator.connect(gainNode);
        gainNode.connect(masterGain);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.1);
      }

      function playScoreSound() {
        initAudio();
        const frequencies = [523, 659, 784];

        frequencies.forEach((freq, index) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(
            freq,
            audioContext.currentTime + index * 0.05
          );

          gainNode.gain.setValueAtTime(
            0.12,
            audioContext.currentTime + index * 0.05
          );
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + index * 0.05 + 0.2
          );

          oscillator.connect(gainNode);
          gainNode.connect(masterGain);

          oscillator.start(audioContext.currentTime + index * 0.05);
          oscillator.stop(audioContext.currentTime + index * 0.05 + 0.2);
        });
      }

      function playGameOverSound() {
        initAudio();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(350, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(
          150,
          audioContext.currentTime + 0.8
        );

        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 0.8
        );

        oscillator.connect(gainNode);
        gainNode.connect(masterGain);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.8);
      }

      function playStartSound() {
        initAudio();
        const frequencies = [262, 330, 392, 523];

        frequencies.forEach((freq, index) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(
            freq,
            audioContext.currentTime + index * 0.08
          );

          gainNode.gain.setValueAtTime(
            0.1,
            audioContext.currentTime + index * 0.08
          );
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + index * 0.08 + 0.3
          );

          oscillator.connect(gainNode);
          gainNode.connect(masterGain);

          oscillator.start(audioContext.currentTime + index * 0.08);
          oscillator.stop(audioContext.currentTime + index * 0.08 + 0.3);
        });
      }

      function playNewRecordSound() {
        initAudio();
        const frequencies = [523, 659, 784, 1047, 1319];

        frequencies.forEach((freq, index) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(
            freq,
            audioContext.currentTime + index * 0.1
          );

          gainNode.gain.setValueAtTime(
            0.15,
            audioContext.currentTime + index * 0.1
          );
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + index * 0.1 + 0.4
          );

          oscillator.connect(gainNode);
          gainNode.connect(masterGain);

          oscillator.start(audioContext.currentTime + index * 0.1);
          oscillator.stop(audioContext.currentTime + index * 0.1 + 0.4);
        });
      }

      let gameStarted = false;
      let gameRunning = false;
      let score = 0;
      let bestScore = localStorage.getItem('skyNavigatorBest') || 0;
      let distance = 0;

      const bird = {
        x: 100,
        y: canvas.height / 2,
        width: 30,
        height: 25,
        velocity: 0,
        gravity: 0.4,
        jumpStrength: -8,
        rotation: 0,
      };

      let pipes = [];
      let clouds = [];
      let particles = [];

      const pipeWidth = 60;
      const pipeGap = 180;
      const pipeSpeed = 3;
      let frameCount = 0;

      for (let i = 0; i < 8; i++) {
        clouds.push({
          x: Math.random() * canvas.width * 2,
          y: Math.random() * canvas.height * 0.3,
          size: Math.random() * 40 + 20,
          speed: Math.random() * 0.5 + 0.2,
        });
      }

      canvas.addEventListener('click', flap);
      document.addEventListener('keydown', e => {
        if (e.code === 'Space') {
          e.preventDefault();
          flap();
        }
        if (e.key.toLowerCase() === 'r') {
          restartGame();
        }
      });

      function flap() {
        if (!gameStarted) {
          startGame();
          return;
        }

        if (gameRunning) {
          bird.velocity = bird.jumpStrength;
          createParticles(bird.x, bird.y + bird.height / 2);
          playFlapSound();
        }
      }

      function startGame() {
        gameStarted = true;
        gameRunning = true;
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('bestValue').textContent = bestScore;
        playStartSound();
        resetGame();
      }

      function resetGame() {
        bird.y = canvas.height / 2;
        bird.velocity = 0;
        bird.rotation = 0;
        score = 0;
        distance = 0;
        pipes = [];
        particles = [];
        frameCount = 0;

        for (let i = 0; i < 3; i++) {
          createPipe(canvas.width + i * 250);
        }
      }

      function createPipe(x) {
        const pipeHeight =
          Math.random() * (canvas.height - pipeGap - 200) + 100;
        pipes.push({
          x: x,
          topHeight: pipeHeight,
          bottomY: pipeHeight + pipeGap,
          bottomHeight: canvas.height - (pipeHeight + pipeGap),
          passed: false,
        });
      }

      function createParticles(x, y) {
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: x,
            y: y,
            vx: Math.random() * 4 - 2,
            vy: Math.random() * 4 - 2,
            life: 20,
            maxLife: 20,
            size: Math.random() * 3 + 1,
          });
        }
      }

      function updateBird() {
        if (!gameRunning) return;
        bird.velocity += bird.gravity;
        bird.y += bird.velocity;
        bird.rotation = Math.min(Math.max(bird.velocity * 0.08, -0.4), 1.2);
        if (bird.y < 0) {
          bird.y = 0;
          bird.velocity = Math.max(bird.velocity, 0);
        }
        if (bird.y + bird.height > canvas.height) {
          gameOver();
        }
      }

      function updatePipes() {
        if (!gameRunning) return;
        for (let i = pipes.length - 1; i >= 0; i--) {
          const pipe = pipes[i];
          pipe.x -= pipeSpeed;

          if (!pipe.passed && bird.x > pipe.x + pipeWidth) {
            pipe.passed = true;
            score++;
            playScoreSound();
          }

          if (checkPipeCollision(pipe)) {
            gameOver();
            return;
          }

          if (pipe.x + pipeWidth < 0) {
            pipes.splice(i, 1);
          }
        }

        if (pipes.length < 3) {
          createPipe(pipes[pipes.length - 1].x + 250);
        }

        distance += pipeSpeed * 0.1;
      }

      function checkPipeCollision(pipe) {
        if (bird.x + bird.width > pipe.x && bird.x < pipe.x + pipeWidth) {
          if (bird.y < pipe.topHeight || bird.y + bird.height > pipe.bottomY) {
            return true;
          }
        }
        return false;
      }

      function updateClouds() {
        for (let cloud of clouds) {
          cloud.x -= cloud.speed;
          if (cloud.x + cloud.size < 0) {
            cloud.x = canvas.width + Math.random() * 200;
            cloud.y = Math.random() * canvas.height * 0.3;
          }
        }
      }

      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const particle = particles[i];
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.life--;

          if (particle.life <= 0) {
            particles.splice(i, 1);
          }
        }
      }

      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#87CEEB');
        gradient.addColorStop(1, '#E0F6FF');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      function drawClouds() {
        ctx.fillStyle = '#FFFFFF';
        for (let cloud of clouds) {
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
          ctx.arc(
            cloud.x + cloud.size * 0.7,
            cloud.y,
            cloud.size * 0.8,
            0,
            Math.PI * 2
          );
          ctx.arc(
            cloud.x + cloud.size * 1.3,
            cloud.y,
            cloud.size * 0.6,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      function drawBird() {
        ctx.save();
        ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
        ctx.rotate(bird.rotation);
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(
          -bird.width / 2,
          -bird.height / 2,
          bird.width,
          bird.height
        );
        ctx.fillStyle = '#FFA500';
        const wingFlap = Math.sin(frameCount * 0.3) * 5;
        ctx.fillRect(
          -bird.width / 2 + 5,
          -bird.height / 2 + 5 + wingFlap,
          15,
          8
        );

        ctx.fillStyle = '#FF6347';
        ctx.fillRect(bird.width / 2 - 5, -3, 8, 6);
        ctx.fillStyle = '#000000';
        ctx.fillRect(bird.width / 2 - 15, -bird.height / 2 + 5, 4, 4);
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(bird.width / 2 - 14, -bird.height / 2 + 6, 2, 2);
        ctx.restore();
      }

      function drawPipes() {
        ctx.fillStyle = '#228B22';
        for (let pipe of pipes) {
          ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
          ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, pipe.bottomHeight);
          ctx.fillStyle = '#32CD32';
          ctx.fillRect(pipe.x - 5, pipe.topHeight - 20, pipeWidth + 10, 20);
          ctx.fillRect(pipe.x - 5, pipe.bottomY, pipeWidth + 10, 20);
          ctx.fillStyle = '#228B22';
        }
      }

      function drawParticles() {
        for (let particle of particles) {
          const alpha = particle.life / particle.maxLife;
          ctx.globalAlpha = alpha;
          ctx.fillStyle = '#87CEEB';
          ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
        }
        ctx.globalAlpha = 1;
      }

      function drawUI() {
        document.getElementById('scoreValue').textContent = score;
        document.getElementById('heightValue').textContent =
          Math.floor(distance);
      }

      function gameOver() {
        gameRunning = false;
        let newRecord = false;
        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem('skyNavigatorBest', bestScore);
          newRecord = true;
        }

        document.getElementById('finalScore').textContent = score;
        document.getElementById('finalDistance').textContent =
          Math.floor(distance);
        document.getElementById('newRecord').style.display = newRecord
          ? 'block'
          : 'none';
        document.getElementById('gameOverScreen').style.display = 'block';

        if (newRecord) {
          playNewRecordSound();
        } else {
          playGameOverSound();
        }
      }

      function restartGame() {
        gameRunning = true;
        document.getElementById('gameOverScreen').style.display = 'none';
        resetGame();
      }

      function gameLoop() {
        frameCount++;

        updateBird();
        updatePipes();
        updateClouds();
        updateParticles();
        drawBackground();
        drawClouds();
        drawPipes();
        drawBird();
        drawParticles();
        drawUI();
        requestAnimationFrame(gameLoop);
      }
      document.getElementById('bestValue').textContent = bestScore;
      gameLoop();
      document.addEventListener('click', initAudio, { once: true });
      document.addEventListener('keydown', initAudio, { once: true });
    </script>
  </body>
</html>
